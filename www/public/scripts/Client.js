// @hash v3-1EA48A6FAD98BB52E7CB92D8105A09FF82E61F5A
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:22
///////////////////////////////////////////////////////////////////////////////
const ClientDevelopment = new class {
  constructor() {
    this.online = document.getElementById("client-development-online");
    this.ping = document.getElementById("client-development-ping");
    this.frames = document.getElementById("client-development-frames");
  }

}();// @hash v3-A159510A2B01F03E14DBF6041DBD0020B18ED0B9
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:22
///////////////////////////////////////////////////////////////////////////////
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class Keys {}

_defineProperty(Keys, "down", {});

;
window.addEventListener("keydown", event => {
  Keys.down[event.code] = performance.now();
});
window.addEventListener("keyup", event => {
  delete Keys.down[event.code];
});
window.addEventListener("blur", () => {
  for (let key in Keys.down) delete Keys.down[key];
});// @hash v3-D1952804688F6D4332037EFB52AA5ECF65297136
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:22
///////////////////////////////////////////////////////////////////////////////
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class Socket {}

_defineProperty(Socket, "connected", false);

_defineProperty(Socket, "sent", 0);

_defineProperty(Socket, "received", 0);

_defineProperty(Socket, "open", function (url = "ws" + (Loader.settings.socket.ssl ? "s" : "") + "://" + Loader.settings.socket.address + ":" + Loader.settings.socket.port + "/" + key) {
  return new Promise(function (resolve, failure) {
    console.log("[%cSocket%c]%c Connecting to the server at " + url + "...", "color: orange", "color: inherit", "color: lightblue");
    const timestamp = performance.now();
    const server = new WebSocket(url);

    server.onopen = function () {
      Socket.connected = true;
      console.log("[%cSocket%c]%c Connected to the server after " + Math.floor(performance.now() - timestamp) + "ms!", "color: orange", "color: inherit", "color: lightblue");

      server.onopen = function () {};

      server.onclose = function () {
        if (!Socket.connected) return;
        Socket.connected = false;
        Loader.setError("Lost connection with the server...");
        Loader.show();
      };

      SocketMessages.block("OnSocketPing");
      setInterval(async function () {
        const time = Date.now();
        const tick = performance.now();
        const received = Socket.received;
        const result = await SocketMessages.sendCall({
          OnSocketPing: null
        }, "OnSocketPing");
        const sent = Socket.sent; //console.log("[%cSocketNetwork%c]%c Communicated ping " + (Math.round((performance.now() - tick) *  100) / 100) + "ms (to " + Math.round(result.time - time) + "ms, from " + Math.round(Date.now() - result.time) + "ms); sent " + sent + "/" + result.received + "; received " + received + "/" + result.sent, "color: orange", "color: inherit", "color: lightblue");

        ClientDevelopment.ping.innerText = Math.round((performance.now() - tick) * 100) / 100;
      }, 1000);
      SocketMessages.block("OnSocketUpdate");
      SocketMessages.register("OnSocketUpdate", function (data) {
        //Client.development.$uptime.html("Uptime: " + data.uptime + "");
        ClientDevelopment.online.innerText = data.users;
      });
      resolve(server);
    };

    server.onmessage = function (data) {
      Socket.received++;
      const message = JSON.parse(data.data);

      for (let key in message) SocketMessages.call(key, message[key]);
    };

    server.onclose = function () {
      console.log("[%cSocket%c]%c Failed to connect to the server after " + Math.floor(performance.now() - timestamp) + "ms!", "color: orange", "color: inherit", "color: lightblue");
      failure(server);
    };
  });
});

;// @hash v3-A9189BC89EF5173C653086597ADB3F551E8B6C66
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:22
///////////////////////////////////////////////////////////////////////////////
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class SocketMessages {
  static register(event, callback) {
    if (SocketMessages.events[event] == undefined) {
      SocketMessages.events[event] = []; //Client.utils.log("SocketMessages", "Registered a new event handler for " + event + "!");
    }

    const index = SocketMessages.events[event].push(callback); //Client.utils.log("SocketMessages", "Registered event handler " + index + " for " + event + "!");
  }

  static unregister(event, callback) {
    if (SocketMessages.events[event] == undefined) return;
    const index = SocketMessages.events[event].indexOf(callback);
    if (index == -1) return;
    SocketMessages.events[event].splice(index, 1); //Client.utils.log("SocketMessages", "Unregistered event handler " + index + " for " + event + "!");

    if (SocketMessages.events[event].length == 0) delete SocketMessages.events[event];
  }

  static send(message) {
    if (Socket.server == undefined) return;
    Socket.sent++;
    Socket.server.send(JSON.stringify(message));
  }

  static sendCall(message, event, correct = undefined) {
    return new Promise(function (resolve) {
      const task = function (data) {
        if (correct != undefined && correct(data) == 0) return;
        SocketMessages.unregister(event, task);
        resolve(data);
      };

      SocketMessages.register(event, task);
      SocketMessages.send(message);
    });
  }

  static block(event) {
    SocketMessages.blocks[event] = 1;
  }

  static call(event, data) {
    if (SocketMessages.blocks[event] != 1) console.log("[%cSocketMessage%c]%c Received " + event + " from the server: %o", "color: orange", "color: inherit", "color: lightblue", data);
    if (SocketMessages.events[event] == undefined) console.warn("[%cSocketMessage%c]%c Event " + event + " does not have any client handlers!", "color: orange", "color: inherit", "color: lightblue");

    for (let index in SocketMessages.events[event]) SocketMessages.events[event][index](data);
  }

}

_defineProperty(SocketMessages, "events", {});

_defineProperty(SocketMessages, "blocks", {});

;// @hash v3-5ECF94009FE30E5FF15531D624AA68DD0EDF3BC9
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:22
///////////////////////////////////////////////////////////////////////////////
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class Assets {
  static async getManifest(asset, library = true) {
    if (Assets.cache[asset] == undefined) Assets.cache[asset] = {};
    if (Assets.cache[asset].manifest != undefined) return Assets.cache[asset].manifest;
    await Assets.downloadManifest(asset, library);
    return Assets.cache[asset].manifest;
  }

  static async downloadManifest(asset, library = true) {
    const name = asset.substring(asset.lastIndexOf('/') + 1);
    const path = Loader.settings.cdn + (library ? "assets/" + asset + "/" + name + ".json" : "assets/" + asset + ".json");
    if (Assets.promises[asset] == undefined) Assets.promises[asset] = {};
    if (Assets.promises[asset] == undefined) Assets.promises[asset] = {};

    if (Assets.promises[asset].manifest != undefined) {
      return new Promise(function (resolve) {
        Assets.promises[asset].manifest.push(function () {
          resolve();
        });
      });
    }

    Assets.promises[asset].manifest = [];
    return new Promise(function (resolve) {
      fetch(path).then(response => response.json().then(manifest => {
        Assets.cache[asset].manifest = manifest;

        for (let index in Assets.promises[asset].manifest) Assets.promises[asset].manifest[index]();

        resolve();
      })).catch(function () {
        Assets.cache[asset].manifest = {};

        for (let index in Assets.promises[asset].manifest) Assets.promises[asset].manifest[index]();

        resolve();
      });
    });
  }

  static async getSpritesheet(asset, library = true) {
    if (Assets.cache[asset] == undefined) Assets.cache[asset] = {};
    if (Assets.cache[asset].spritesheet != undefined) return Assets.cache[asset].spritesheet;
    await Assets.downloadSpritesheet(asset, library);
    return Assets.cache[asset].spritesheet;
  }

  static async downloadSpritesheet(asset, library = true) {
    const name = asset.substring(asset.lastIndexOf('/') + 1);
    let path = Loader.settings.cdn + (library ? "assets/" + asset + "/" + name : "assets/" + asset);
    if (library == true || asset.indexOf('.') == -1) path += ".png";
    if (Assets.promises[asset] == undefined) Assets.promises[asset] = [];

    if (Assets.promises[asset].spritesheet != undefined) {
      return new Promise(function (resolve) {
        Assets.promises[asset].spritesheet.push(function () {
          resolve();
        });
      });
    }

    Assets.promises[asset].spritesheet = [];
    return new Promise(function (resolve) {
      const image = new Image();

      image.onload = function () {
        Assets.cache[asset].spritesheet = image;

        for (let index in Assets.promises[asset].spritesheet) Assets.promises[asset].spritesheet[index]();

        resolve();
      };

      image.onerror = function () {
        Assets.cache[asset].spritesheet = image;

        for (let index in Assets.promises[asset].spritesheet) Assets.promises[asset].spritesheet[index]();

        resolve();
      };

      image.src = path;
    });
  }

  static async getSprite(asset, sprite, flipped = false) {
    const manifest = await Assets.getManifest(asset);
    const spritesheet = await Assets.getSpritesheet(asset);
    if (Assets.cache[asset].sprites == undefined) Assets.cache[asset].sprites = {};
    if (Assets.cache[asset].spritesData == undefined) Assets.cache[asset].spritesData = {};
    if (Assets.cache[asset].sprites[sprite + (flipped == true ? "?flipped=true" : "")] != undefined) return Assets.cache[asset].sprites[sprite + (flipped == true ? "?flipped=true" : "")];
    const data = manifest.sprites[sprite];

    if (data == undefined) {
      console.warn("[Assets] " + sprite + " in library " + asset + " does not exist!");
      return null;
    }

    if (data.link != undefined) {
      for (let key in manifest.sprites[data.link]) data[key] = manifest.sprites[data.link][key];

      delete data.link;
    }

    const canvas = document.createElement("canvas");
    canvas.width = data.width;
    canvas.height = data.height;
    const context = canvas.getContext("2d");
    context.drawImage(spritesheet, parseInt(data.left), parseInt(data.top), parseInt(data.width), parseInt(data.height), 0, 0, parseInt(data.width), parseInt(data.height));
    Assets.cache[asset].sprites[sprite] = canvas;

    if (flipped == true) {
      const flippedCanvas = document.createElement("canvas");
      flippedCanvas.width = data.width;
      flippedCanvas.height = data.height;
      const flippedContext = flippedCanvas.getContext("2d");
      flippedContext.translate(flippedContext.canvas.width, 0);
      flippedContext.scale(-1, 1);
      flippedContext.drawImage(canvas, 0, 0);
      Assets.cache[asset].sprites[sprite + "?flipped=true"] = flippedCanvas;
      return Assets.cache[asset].sprites[sprite + "?flipped=true"];
    }

    return Assets.cache[asset].sprites[sprite];
  }

  static async getSpriteData(asset, sprite) {
    const image = await Assets.getSprite(asset, sprite);
    if (Assets.cache[asset].spritesData[sprite] != undefined) return Assets.cache[asset].spritesData[sprite];
    Assets.cache[asset].spritesData[sprite] = image.getContext("2d").getImageData(0, 0, image.width, image.height);
    return Assets.cache[asset].spritesData[sprite];
  }

  static async getSpriteColor(asset, sprite, color) {
    const image = await Assets.getSprite(asset, sprite);
    if (Assets.cache[asset].sprites[sprite + "?color=" + color] != undefined) return Assets.cache[asset].sprites[sprite + "?color=" + color];
    const colorCanvas = document.createElement("canvas");
    colorCanvas.width = image.width;
    colorCanvas.height = image.height;
    const colorContext = colorCanvas.getContext("2d");
    colorContext.drawImage(image, 0, 0);
    colorContext.globalCompositeOperation = "multiply";
    colorContext.fillStyle = color.replace('0x', '#');
    colorContext.fillRect(0, 0, image.width, image.height);
    const canvas = document.createElement("canvas");
    canvas.width = image.width;
    canvas.height = image.height;
    const context = canvas.getContext("2d");
    context.drawImage(image, 0, 0);
    context.globalCompositeOperation = "source-in";
    context.drawImage(colorCanvas, 0, 0);
    Assets.cache[asset].sprites[sprite + "?color=" + color] = canvas;
    return Assets.cache[asset].sprites[sprite + "?color=" + color];
  }

}

_defineProperty(Assets, "cache", {});

_defineProperty(Assets, "promises", {});

;// @hash v3-C7A81D43A405DF63320E469D0AEA1DD474870B1C
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:22
///////////////////////////////////////////////////////////////////////////////
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class Game {
  static async getUser(id) {
    if (Game.users[id] != undefined) return Game.users[id];

    if (Game.promises.users[id] != undefined) {
      return new Promise(function (resolve) {
        Game.promises.users[id].push(function (data) {
          resolve(data);
        });
      });
    }

    Game.promises.users[id] = [];
    Game.users[id] = await SocketMessages.sendCall({
      OnUserRequest: id
    }, "OnUserRequest", x => x.id == id);

    for (let index in Game.promises.users[id]) Game.promises.users[id][index](Game.users[id]);

    return Game.users[id];
  }

}

_defineProperty(Game, "users", {});

_defineProperty(Game, "promises", {
  users: {}
});

;// @hash v3-AE9A44DE20B8D9F4144AF472A822F540149646AD
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:22
///////////////////////////////////////////////////////////////////////////////
const Dialogs = new function () {
  this.element = document.createElement("div");
  this.element.id = "dialogs";
  Client.element.appendChild(this.element);
  this.entities = [];

  this.sort = () => {
    this.entities.sort(function (a, b) {
      return a.timestamp - b.timestamp;
    });

    for (let index in this.entities) {
      if (this.entities[index].element == null) continue;
      this.entities[index].element.style.zIndex = 1 + index;
    }
  };

  this.add = entity => {
    this.entities.push(entity);
    entity.events.show.push(function () {
      entity.timestamp = performance.now();
      this.sort();
    });
  };
}();
window.addEventListener("keyup", event => {
  if (event.code != "Escape") return;
  let current = -1;

  for (let index = Dialogs.entities.length - 1; index != -1; index--) {
    if (!Dialogs.entities[index].active) continue;
    current = index;
    break;
  }

  if (current == -1) return;
  Dialogs.entities[current].hide();

  for (let index = current - 1; index != -1; index--) {
    if (!Dialogs.entities[index].active) continue;
    Dialogs.entities[index].show();
    break;
  }
});// @hash v3-08D91BD5DB0276E99B423DA80A6DC3017BB840F4
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:22
///////////////////////////////////////////////////////////////////////////////
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class Dialog {
  constructor(settings = {}) {
    _defineProperty(this, "resizableMouseDown", false);

    _defineProperty(this, "resizableMousePosition", {
      left: null,
      top: null
    });

    _defineProperty(this, "resizableMousePositionStart", {
      left: null,
      top: null
    });

    _defineProperty(this, "resizableOnMouseMoveAlias", null);

    _defineProperty(this, "resizableOnMouseUpAlias", null);

    _defineProperty(this, "resizableOnMouseDownAlias", null);

    this.events = {
      show: [],
      hide: [],
      create: [],
      destroy: []
    };
    this.active = false;
    this.created = false;
    this.size = {
      width: settings.size != undefined ? settings.size.width || "auto" : "auto",
      height: settings.size != undefined ? settings.size.height || "auto" : "auto"
    };
    this.offset = settings.offset || {
      type: "center",
      left: 0,
      top: 0
    };
    this.title = settings.title || "Loading...";
    this.resizable = settings.resizable || false;
    Dialogs.add(this);
  }

  create() {
    console.log("create");
    if (this.created) return;
    this.created = true;
    this.element = document.createElement("div");
    this.element.classList.add("dialog-default");
    this.element.innerHTML = `
            <div class="dialog-default-header">
                <p class="dialog-default-header-title">Loading...</p>

                <div class="dialog-default-header-buttons">
                    <div class="dialog-default-header-info"></div>
                    <div class="dialog-default-header-close"></div>
                </div>
            </div>

            <div class="dialog-default-container">
                <div class="dialog-default-content"></div>

                <div class="dialog-default-overlay"></div>
            </div>  
        `;
    this.element.style.position = "absolute";
    this.element.addEventListener("mousedown", event => {
      this.timestamp = performance.now();
      Dialogs.sort();
    });
    this.element.querySelector(".dialog-default-header-close").addEventListener("click", event => this.destroy());
    const header = this.element.querySelector(".dialog-default-header");
    {
      header.addEventListener("mousedown", event => {
        event = event || window.event;
        event.preventDefault();
        let clientX = event.clientX;
        let clientY = event.clientY;

        function mousemove(event) {
          event = event || window.event;
          event.preventDefault();
          let offsetX = clientX - event.clientX;
          let offsetY = clientY - event.clientY;
          clientX = event.clientX;
          clientY = event.clientY;
          header.parentElement.style.top = header.parentElement.offsetTop - offsetY + "px";
          header.parentElement.style.left = header.parentElement.offsetLeft - offsetX + "px";
        }

        ;

        function mouseup() {
          document.removeEventListener("mouseup", mouseup);
          document.removeEventListener("mousemove", mousemove);
        }

        ;
        document.addEventListener("mouseup", mouseup);
        document.addEventListener("mousemove", mousemove);
      });
    }
    Dialogs.element.appendChild(this.element);
    /*.draggable({
    //    handle: ".dialog-default-header"
    //}).css("position", "absolute").on("mousedown", event => {
        this.timestamp = performance.now();
          Dialogs.sort();
    }).on("click", ".dialog-default-header-close", event => this.destroy()).appendTo(Dialogs.$element);*/

    ;
    this.container = this.element.querySelector(".dialog-default-container");
    this.content = this.element.querySelector(".dialog-default-content");
    this.overlay = this.element.querySelector(".dialog-default-overlay");
    this.setTitle(this.title);
    this.setSize(this.size.width, this.size.height);
    this.setOffset(this.offset.type, this.offset.left, this.offset.top);
    this.setResizable(this.resizable);

    for (let index in this.events.create) this.events.create[index]();
  }

  show() {
    console.log("show");
    this.create();
    this.active = true;
    console.log(this.events.show.length);

    for (let index = 0; index < this.events.show.length; index++) {
      console.log("call " + index);
      this.events.show[index]();
    }

    this.element.style.display = "block";
  }

  hide() {
    if (!this.active) return;
    this.active = false;

    for (let index in this.events.hide) this.events.hide[index]();

    this.element.style.display = "none";
  }

  toggle() {
    return !this.active ? this.show() : this.hide();
  }

  destroy() {
    this.hide();
    if (!this.created) return;
    this.created = false;
    this.element.remove();
    delete this.element;

    for (let index in this.events.destroy) this.events.destroy[index]();
  }

  pause() {
    if (!this.created) return;
    this.overlay.style.display = "block";
    this.element.querySelector(".dialog-default-header-title").innerText = "Loading...";
  }

  unpause() {
    if (!this.created) return;
    this.overlay.style.display = "none";
    this.element.querySelector(".dialog-default-header-title").innerText = this.title;
  }

  setTitle(title) {
    this.title = title;
    this.element.querySelector(".dialog-default-header-title").innerText = this.title;
  }

  setSize(width, height = width) {
    this.width = width;
    this.height = height;
    this.container.style.width = `${width}px`;
    this.container.style.height = `${height}px`;
    this.container.style.minWidth = `${width}px`;
    this.container.style.minHeight = `${height}px`;
  }

  setOffset(type, left = 0, top = 0) {
    if (type == "center") return this.setOffset("absolute", this.element.parentElement.width / 2 - this.element.width / 2 + left, this.element.parentElement.height / 2 - this.element.height / 2 + top);
    this.element.style.left = left;
    this.element.style.top = top;
  }

  resizableOnMouseDown(event) {
    this.resizableMouseDown = true;
    this.resizableMousePositionStart = {
      left: event.clientX,
      top: event.clientY
    };
    this.resizableMousePosition = {
      left: event.clientX,
      top: event.clientY
    };

    this.resizableOnMouseMoveAlias = event => this.resizableOnMouseMove(event);

    this.resizableOnMouseUpAlias = event => this.resizableOnMouseUp(event);

    window.addEventListener("mousemove", this.resizableOnMouseMoveAlias);
    window.addEventListener("mouseup", this.resizableOnMouseUpAlias);
  }

  resizableOnMouseMove(event, width, height) {
    if (this.container.width > this.width || event.clientX >= this.resizableMousePositionStart.left) this.container.style.width = `${this.container.width + (event.clientX - this.resizableMousePosition.left)}px`;
    if (this.container.height > this.height || event.clientY >= this.resizableMousePositionStart.top) this.container.style.height = `${this.container.height + (event.clientY - this.resizableMousePosition.top)}px`;
    this.resizableMousePosition = {
      left: event.clientX,
      top: event.clientY
    };
  }

  resizableOnMouseUp(event) {
    this.resizableMouseDown = false;
    window.removeEventListener("mousemove", this.resizableOnMouseMoveAlias);
    window.removeEventListener("mouseup", this.resizableOnMouseUpAlias);
  }

  setResizable(enabled = true) {
    if (enabled && !this.resizable) {
      this.resizableElement = document.createElement("div");
      this.resizableElement.classList.add("dialog-default-resizable");
      this.element.appendChild(this.resizableElement);

      this.resizableOnMouseDownAlias = event => this.resizableOnMouseDown(event);

      this.resizableElement.addEventListener("mousedown", this.resizableOnMouseDownAlias);
    } else if (!enabled && this.resizable) {
      this.resizableElement.removeEventListener("mousedown", this.resizableOnMouseDownAlias);
      this.resizableElement.remove();
      window.removeEventListener("mousemove", this.resizableOnMouseMoveAlias);
      window.removeEventListener("mouseup", this.resizableOnMouseUpAlias);
    }

    this.resizable = enabled;
  }

}

;// @hash v3-93A06177B81E90510C444678D714728070BAE6EB
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:22
///////////////////////////////////////////////////////////////////////////////
class CameraDialog extends Dialog {
  create() {
    super.create();
    this.element.classList.add("dialog-camera");
    this.grid = document.createElement("div");
    this.grid.className = "dialog-camera-grid";
    this.content.appendChild(this.grid);
  }

}

;// @hash v3-3CDBAD4F9667CD2ED704B77A4CEC83476F6030A9
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:22
///////////////////////////////////////////////////////////////////////////////
class DialogHeader {
  constructor(settings = {}) {
    this.element = document.createElement("div");
    this.element.className = "dialog-header";
    this.element.innerHTML = `
            <canvas class="dialog-header-image"></canvas>

            <div class="dialog-header-container">
                <div class="dialog-header-content">
                    <div class="dialog-header-icon"></div>
                    <div class="dialog-header-details">
                        <h1 class="dialog-header-title"></h1>
                        <p class="dialog-header-description"></p>
                    </div>
                </div>
            </div>
        `;
    this.image = this.element.querySelector(".dialog-header-image");
    this.content = this.element.querySelector(".dialog-header-container");
    this.set(settings);
  }

  setTitle(title) {
    this.content.querySelector(".dialog-header-title").innerHTML = title;
  }

  setDescription(description) {
    this.content.querySelector(".dialog-header-description").innerHTML = description;
  }

  getContext(context) {
    this.image.width = this.element.clientWidth;
    this.image.height = this.element.clientHeight;
    return this.image.getContext(context);
  }

  setIcon(element) {
    const icon = this.content.querySelector(".dialog-header-icon");
    icon.style.minWidth = "64px";
    icon.innerHTML = "";
    icon.appendChild(element);
  }

  set(settings) {
    if (settings.height != undefined) this.element.style.height = settings.height;
  }

}

;// @hash v3-BCAC6104FB71D8CE01C7470798F778424198738C
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:22
///////////////////////////////////////////////////////////////////////////////
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class DialogTabs {
  constructor(height) {
    _defineProperty(this, "active", null);

    _defineProperty(this, "callbacks", []);

    this.element = document.createElement("div");
    this.element.className = "dialog-tabs";
    this.element.innerHTML = `
            <div class="dialog-tabs-header"></div>

            <div class="dialog-tabs-container">
                <div class="dialog-tabs-content"></div>
            </div>
        `;
    this.element.style.height = `${height}px`;
    this.header = this.element.querySelector(".dialog-tabs-header");
    this.content = this.element.querySelector(".dialog-tabs-content");
    this.buttons = {};
  }

  add(identifier, text, callback = undefined, disabled = false) {
    const element = document.createElement("div");
    element.classList.add("dialog-tabs-button");
    element.innerText = text;
    this.header.appendChild(element);

    if (disabled) {
      element.style.pointerEvents = "none";
      element.style.opacity = .5;
    }

    this.buttons[identifier] = {
      element,
      callback
    };
    const entity = this;
    element.addEventListener("click", () => {
      entity.show(identifier);
    });
  }

  hide() {
    this.active?.removeAttribute("active");
    this.active = null;
    this.content.innerHTML = "";
  }

  async show(identifier = this.selected) {
    if (identifier == undefined) return;
    this.hide();
    this.active = this.buttons[identifier].element;
    this.active.setAttribute("active", "");
    this.content.innerHTML = "";

    for (let index in this.callbacks) await this.callbacks[index](identifier, this.content);

    if (this.buttons[identifier].callback != undefined) this.buttons[identifier].callback(this.content);
    this.selected = identifier;
  }

  click(callback) {
    this.callbacks.push(callback);
  }

}

;// @hash v3-C2EED5030BA1586E7A298E50D4FC3C04B61A88AB
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:22
///////////////////////////////////////////////////////////////////////////////
class DialogSelection {
  constructor(placeholder, options = []) {
    this.element = document.createElement("div");
    this.element.classList.add("dialog-selection");
    this.element.innerHTML = `
            <div class="dialog-selection-placeholder">${placeholder}</div>
                
            <div class="dialog-selection-options"></div>
        `;
    this.placeholder = this.element.querySelector(".dialog-selection-placeholder");
    const optionsElement = this.element.querySelector(".dialog-selection-options");
    this.placeholder.addEventListener("click", () => {
      optionsElement.style.display = optionsElement.style.display == "none" ? "block" : "none";
    });

    for (let index in options) {
      const option = document.createElement("div");
      option.className = "dialog-selection-option";
      option.value = options[index].value;
      option.innerText = options[index].text;
      optionsElement.appendChild(option);
      option.addEventListener("click", () => {
        optionsElement.querySelector(".dialog-selection-option.active")?.classList.remove("active");
        option.classList.add("active");
        this.placeholder.innerText = option.innerText;
        this.placeholder.value = option.value;
        optionsElement.style.display = "none";
      });
    }
  }

  value() {
    return this.placeholder.value;
  }

}

;// @hash v3-DC453971A8178ACD5E764ABF8FBB4092CE85C266
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:22
///////////////////////////////////////////////////////////////////////////////
class DisplayDialog extends Dialog {
  constructor(settings = {}) {
    settings.offset = {
      type: "center"
    };
    settings.size = {
      width: 420,
      height: 220
    };
    super(settings);
  }

  create() {
    super.create();
    this.element.classList.add("dialog-display");
    this.events.create.push(() => {
      this.header = document.createElement("div");
      this.header.className = "dialog-display-header";
      this.content.appendChild(this.header);
      const display = document.createElement("div");
      display.className = "dialog-display-content";
      this.header.appendChild(display);
      const container = document.createElement("div");
      container.className = "dialog-display-header-info";
      this.header.appendChild(container);
      const info = document.createElement("div");
      info.className = "dialog-display-header-info-content";
      container.appendChild(info);
      display.innerHTML += `<div class="dialog-display-content-star"></div>`;
      this.display = document.createElement("div");
      this.display.className = "dialog-display-content-item";
      display.appendChild(this.display);
      const button = document.createElement("div");
      button.className = "dialog-button";
      button.innerText = "Okay!";
      this.content.appendChild(button);
      button.addEventListener("click", () => {
        this.hide();
      });
    });
    this.events.show.push(function () {
      if (this.effects != undefined) {
        this.effects.remove();
        delete this.effects;
      }

      this.effects = document.createElement("div");
      this.effects.className = "dialog-display-content-effects";
      this.display.appendChild(this.effects);
      const sizes = ["small", "small", "medium", "big"];

      for (let index = 0; index < 20; index++) {
        setTimeout(function () {
          const effect = document.createElement("div");
          effect.className = "dialog-display-content-effect";
          this.effects.appendChild(effect);
          effect.style.left = `${3 + Math.floor(Math.random() * 9) * 10}px`;
          effect.style.top = `${3 + Math.floor(Math.random() * 9) * 10}px`;
          effect.classList.add("sprite-display-effect-" + sizes[Math.floor(Math.random() * sizes.length)]);
          /*effect.fadeIn(Math.floor(Math.random() * 500), function() {
              setTimeout(function() {
                  $effect.fadeOut(Math.floor(Math.random() * 500));
              }, Math.floor(Math.random() * 5000));
          });*/
        }, Math.floor(Math.random() * 1500));
      }
    });
  }

}

;// @hash v3-267F1F8ACB6F251806861C167576C9741434586D
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:22
///////////////////////////////////////////////////////////////////////////////
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class Figures {
  static getPartName(part) {
    // "bd","sh","lg","ch","wa","ca","hd","fc","ey","hr","hrb","fa","ea","ha","he"
    switch (part) {
      case "li":
      case "lh":
      case "ls":
        return "LeftArm";

      case "ri":
      case "rh":
      case "rs":
        return "RightArm";

      case "bd":
      case "lg":
        return "Torso";
    }

    return "Body";
  }

  static async getLibrary(id, type) {
    const libraries = Figures.map.map.lib;
    let index = 0;

    for (index in libraries) {
      if (libraries[index].part.length == undefined) libraries[index].part = [libraries[index].part];

      for (let part in libraries[index].part) {
        if (libraries[index].part[part].id == id && libraries[index].part[part].type[0] == type[0] && libraries[index].part[part].type[1] == type[1]) {
          return libraries[index].id;
        }
      }
    }

    return libraries[index].id;
  }

  static async getSetType(type) {
    const sets = Figures.data.figuredata.sets.settype;
    let index = 0;

    for (index in sets) {
      if (sets[index].type != type) continue;
      break;
    }

    return sets[index];
  }

  static async getSetData(set, id) {
    let index = 0;

    for (index in set.set) {
      if (set.set[index].id != id) continue;
      break;
    }

    return set.set[index];
  }

  static getSprite(asset, sprite) {
    const assets = asset.manifest.manifest.library.assets.asset;
    let index = 0;

    for (index in assets) {
      if (assets[index].name != sprite) continue;
      break;
    }

    return assets[index].param.value;
  }

  static async getPalette(palette) {
    const palettes = Figures.data.figuredata.colors.palette;
    let index = 0;

    for (index in palettes) {
      if (palettes[index].id != palette) continue;
      break;
    }

    return palettes[index].color;
  }

  static getPaletteColor(palette, id) {
    let index = 0;

    for (index in palette) {
      if (palette[index].id != id) continue;
      break;
    }

    return palette[index];
  }

  static async getAction(id) {
    let index = 0;

    for (index in Figures.actions.actions.action) {
      if (Figures.actions.actions.action[index].id != id) continue;
      break;
    }

    return Figures.actions.actions.action[index];
  }

  static getEffect(id) {
    for (let index in Figures.effects.map.effect) {
      if (Figures.effects.map.effect[index].id != id) continue;
      return Figures.effects.map.effect[index];
    }

    return null;
  }

  static getEffectAsset(manifest, sprite) {
    let result = null;
    const assets = manifest.manifest.manifest.library.assets.asset;

    for (let index in assets) {
      if (assets[index].name != sprite) continue;
      const offsets = assets[index].param.value.split(',');
      result = {
        offset: {
          left: parseInt(offsets[0]),
          top: parseInt(offsets[1])
        }
      };
      break;
    }
    /*if(manifest.manifest.manifest.library.aliases != null) {
        const aliases = manifest.manifest.manifest.library.aliases.alias;
          for(let index in aliases) {
            if(aliases[index].name != sprite)
                continue;
              const alias = Figures.getEffectAsset(manifest, aliases[index].link);
              for(let key in alias) {
                if(result[key] == undefined)
                    result[key] = alias;
            }
              break;
        }
    }*/


    return result;
  }

  static getEffectComposite(ink) {
    switch (ink) {
      case "33":
        return "lighter";
    }

    return "source-over";
  }

  static getEffectIndex(align) {
    switch (align) {
      case "behind":
        return -100;

      case "bottom":
        return -100;

      case "top":
        return 100;
    }

    return 0;
  }

}

_defineProperty(Figures, "logging", {
  missingSprite: false
});

_defineProperty(Figures, "parts", {
  "cc": "ch",
  "lc": "ls",
  "rc": "rs"
});

_defineProperty(Figures, "actionFrames", {
  "Move": 4,
  "Talk": 2,
  "Wave": 1
});

;
Loader.addAsset(async function () {
  Figures.data = await Assets.getManifest("HabboFigureData");
  Figures.map = await Assets.getManifest("HabboFigureMap");
  Figures.actions = await Assets.getManifest("HabboFigureActions");
  Figures.effects = await Assets.getManifest("HabboFigureEffects");
});// @hash v3-82CA10B5D4DDC0353E3F65588F70ACE9124E1FC6
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class FigureEntity {
  constructor(figure, properties = {}) {
    _defineProperty(this, "events", {
      render: []
    });

    _defineProperty(this, "direction", 2);

    _defineProperty(this, "effect", 0);

    _defineProperty(this, "effectFrame", 0);

    _defineProperty(this, "effectFrames", {});

    _defineProperty(this, "effectDirection", 0);

    _defineProperty(this, "effectRemovals", {});

    _defineProperty(this, "actions", []);

    _defineProperty(this, "actionTimestamp", performance.now());

    _defineProperty(this, "frames", {});

    _defineProperty(this, "data", {});

    this.canvas = document.createElement("canvas");
    this.canvas.width = 256;
    this.canvas.height = 256;
    this.setFigure(figure);

    for (let key in properties) this[key] = properties[key];
  }

  async getSprite(library, type, id, direction, color) {
    const manifest = await Assets.getManifest("HabboFigures/" + library);
    let frame = 0,
        sprite;
    const partName = Figures.getPartName(type).toLowerCase();

    if (this.effectFrames["bodypart"] != undefined && this.effectFrames["bodypart"][partName] != undefined) {
      const action = await Figures.getAction(this.effectFrames["bodypart"][partName].action);
      sprite = "h_" + action.assetpartdefinition + "_" + type + "_" + id + "_" + direction + "_" + frame;
    }

    if (manifest.sprites[library + "_" + sprite] == undefined) {
      for (let index in this.actions) {
        sprite = "h_" + this.actions[index].assetpartdefinition + "_" + type + "_" + id + "_" + direction + "_" + frame;
        if (manifest.sprites[library + "_" + sprite] == undefined) continue;

        if (this.frames[this.actions[index].id] != undefined) {
          frame = this.frames[this.actions[index].id];
          sprite = "h_" + this.actions[index].assetpartdefinition + "_" + type + "_" + id + "_" + direction + "_" + frame;

          if (manifest.sprites[library + "_" + sprite] == undefined) {
            frame = 0;
            sprite = "h_" + this.actions[index].assetpartdefinition + "_" + type + "_" + id + "_" + direction + "_" + frame;
          }
        }

        break;
      }
    }

    if (manifest.sprites[library + "_" + sprite] == undefined) {
      if (Figures.logging.missingSprite) console.warn("[FigureEntity]%c Unable to locate sprite " + sprite + " in library " + library + "!", "color: lightblue");
      return null;
    }

    let image = await Assets.getSprite("HabboFigures/" + library, library + "_" + sprite);
    if (color != undefined && type != "ey") image = await Assets.getSpriteColor("HabboFigures/" + library, library + "_" + sprite, "#" + color);
    const imageData = await Assets.getSpriteData("HabboFigures/" + library, library + "_" + sprite);
    const spriteData = Figures.getSprite(manifest, sprite).split(',');
    return {
      image,
      imageData,
      left: parseInt(spriteData[0]) * -1,
      top: parseInt(spriteData[1]) * -1
    };
  }

  setFigure(figure) {
    this.parts = {};
    this.figure = figure.split('.');

    for (let index = 0; index < this.figure.length; index++) {
      const parts = this.figure[index].split('-');
      const part = parts[0];
      this.parts[part] = {};
      parts.shift();
      if (parts.length == 0) continue;
      this.parts[part].id = parseInt(parts[0]);
      parts.shift();
      if (parts.length == 0) continue;
      this.parts[part].color = [];

      for (let index in parts) this.parts[part].color[index] = parseInt(parts[index]);
    }
  }

  async setAction(id) {
    if (this.actions.findIndex(x => x.id == id) != -1) return;
    const action = await Figures.getAction(id);
    this.actions.push(action);
    this.actions.sort(function (a, b) {
      return parseInt(a.precedence) - parseInt(b.precedence);
    });
  }

  async setActions(actions) {
    this.actions.length = 0;

    for (let key in actions) await this.setAction(actions[key]);

    await this.setAction("Default");
  }

  updateActions() {
    if (this.actions.length == 0 && this.effect == 0) return false;
    const timestamp = performance.now();
    if (timestamp - this.actionTimestamp < 1000 / 12) return false;
    this.actionTimestamp = timestamp;
    let changed = false;

    if (this.effect != 0) {
      changed = true;
      this.effectFrame++;
    }

    for (let index in this.actions) {
      const id = this.actions[index].id;
      if (Figures.actionFrames[id] == undefined) continue;

      if (this.frames[id] != undefined) {
        this.frames[id]++;
        if (this.frames[id] > Figures.actionFrames[id]) this.frames[id] = 0;
      } else this.frames[id] = 0;

      changed = true;
    }

    return changed;
  }

  removeAction(id) {
    const index = this.actions.findIndex(x => x.id == id);
    if (index == -1) return;
    this.actions.splice(index, 1);
  }

  setEffect(id) {
    this.effect = id;
    this.effectFrame = 0;
    this.effectFrames = {};
    this.effectDirection = 0;
    this.effectRemovals = {};
  }

  async process() {
    await this.setAction("Default");
  }

  async render() {
    const context = this.canvas.getContext("2d");
    context.save();
    const layers = {};
    let direction = this.direction > 3 && this.direction < 7 ? 6 - this.direction : this.direction;
    const sprites = await this.renderEffect(direction);
    let offset = Figures.map.offsets["std"],
        offsetName = "std";
    let priorities = Figures.map.priorities["std"][direction];
    let prioritiesChanged = false,
        offsetChanged = false;

    for (let index in this.actions) {
      const stance = this.actions[index].assetpartdefinition;

      if (prioritiesChanged == false) {
        if (Figures.map.priorities[stance] != undefined) {
          if (Figures.map.priorities[stance][direction] != undefined) {
            priorities = Figures.map.priorities[stance][direction];
            prioritiesChanged = true;
          }
        }
      }

      if (offsetChanged == false) {
        if (Figures.map.offsets[stance] != undefined) {
          offsetName = stance;
          if (Figures.map.offsets[stance].link != undefined) offset = Figures.map.offsets[Figures.map.offsets[stance].link];else offset = Figures.map.offsets[stance];
          offsetChanged = true;
        }
      }
    }

    for (let type in priorities) layers[priorities[type]] = [];

    const shadow = await this.getSprite("hh_human_body", "sd", 1, 0, 0);

    if (shadow != null && this.effectRemovals["bd"] == undefined) {
      shadow.alpha = .25;
      layers["bd"].push(shadow);
    }

    for (let set in this.parts) {
      const setType = await Figures.getSetType(set);
      const setData = await Figures.getSetData(setType, this.parts[set].id);
      let palette = undefined,
          color = undefined;
      if (setData.part.length == undefined) setData.part = [setData.part];

      for (let index in setData.part) {
        const id = parseInt(setData.part[index].id);
        const type = setData.part[index].type;
        if (this.effectRemovals[type] == true) continue;
        let color = undefined;
        const colorIndex = parseInt(setData.part[index].colorindex) - 1;

        if (this.parts[set].color != undefined && this.parts[set].color[colorIndex] != undefined) {
          palette = await Figures.getPalette(setType.paletteid);
          color = Figures.getPaletteColor(palette, this.parts[set].color[colorIndex])["#text"];
        }

        const priorityType = Figures.parts[type] != undefined ? Figures.parts[type] : type;

        if (layers[priorityType] == undefined) {
          console.warn("[FigureEntity]%c Unable to locate type " + type + " in current priority list!", "color: lightblue");
          continue;
        }

        const library = await Figures.getLibrary(id, type);
        const sprite = await this.getSprite(library, type, id, direction, color, priorityType);
        if (sprite == null) continue;
        layers[priorityType].push(sprite);
      }
    }

    context.clearRect(0, 0, 256, 256);

    if (this.direction > 3 && this.direction < 7) {
      context.translate(context.canvas.width, 0);
      context.scale(-1, 1);
    }

    for (let type in layers) {
      for (let index in layers[type]) {
        context.globalAlpha = layers[type][index].alpha == undefined ? 1.0 : layers[type][index].alpha;
        context.drawImage(layers[type][index].image, 128 + offset.left + layers[type][index].left, 128 + offset.top + layers[type][index].top);
      }
    }

    if (this.data[offsetName] == undefined) this.data[offsetName] = {};
    if (this.data[offsetName][this.direction] == undefined) this.data[offsetName][this.direction] = context.getImageData(0, 0, context.canvas.width, context.canvas.height);
    sprites.push({
      image: context.canvas,
      imageData: this.data[offsetName][this.direction],
      left: 0,
      top: 0,
      index: 0
    });
    context.restore();

    if (this.effectFrames["fx"] != undefined) {
      if (this.effectFrames["fx"]["avatar"] != undefined) {
        let left = 0,
            top = 0;
        if (this.effectFrames["fx"]["avatar"].dx != undefined) left = parseInt(this.effectFrames["fx"]["avatar"].dx);
        if (this.effectFrames["fx"]["avatar"].dy != undefined) top = parseInt(this.effectFrames["fx"]["avatar"].dy);

        for (let index in sprites) {
          if (this.effectFrames["fx"][sprites[index].base] != undefined) {
            if (this.effectFrames["fx"][sprites[index].base].dx == undefined) sprites[index].left += left;
            if (this.effectFrames["fx"][sprites[index].base].dy == undefined) sprites[index].top += top;
          } else {
            sprites[index].left += left;
            sprites[index].top += top;
          }
        }
      }
    } //Client.utils.warn("FigureEntity", "Render process took ~" + (Math.round((performance.now() - timestamp) * 100) / 100) + "ms to execute...");
    //timestamp = performance.now();


    for (let event in this.events.render) this.events.render[event](sprites); //Client.utils.warn("FigureEntity", "After math render processes took ~" + (Math.round((performance.now() - timestamp) * 100) / 100) + "ms to execute!");

  }

  async renderEffect(direction) {
    const sprites = [];
    this.effectFrames = {};
    this.effectRemovals = {};
    if (this.effect == 0) return sprites;
    const flipped = this.direction > 3 && this.direction < 7;
    const map = Figures.getEffect(this.effect);
    const manifest = await Assets.getManifest("HabboFigures/" + map.lib);
    if (manifest == undefined || manifest.animation == undefined || manifest.animation.animation == undefined) return sprites;
    if (manifest.animation.animation.direction != undefined) this.effectDirection = parseInt(manifest.animation.animation.direction.offset);else this.effectDirection = 0;

    if (manifest.animation.animation.frame != undefined) {
      if (this.effectFrame >= manifest.animation.animation.frame.length) this.effectFrame = 0;
      const frameFx = manifest.animation.animation.frame[this.effectFrame];

      for (let key in frameFx) {
        this.effectFrames[key] = {};

        for (let index in frameFx[key]) this.effectFrames[key][frameFx[key][index].id] = frameFx[key][index];
      }
    }

    if (manifest.animation.animation.sprite != undefined) {
      if (manifest.animation.animation.sprite.length == undefined) manifest.animation.animation.sprite = [manifest.animation.animation.sprite];

      for (let index in manifest.animation.animation.sprite) {
        if (manifest.animation.animation.sprite[index].id == "avatar") continue;
        let frame = 0,
            left = 0,
            top = 0,
            _direction = direction;

        if (this.effectFrames["fx"] != undefined) {
          if (this.effectFrames["fx"][manifest.animation.animation.sprite[index].id] != undefined) {
            if (this.effectFrames["fx"][manifest.animation.animation.sprite[index].id].frame != undefined) frame = parseInt(this.effectFrames["fx"][manifest.animation.animation.sprite[index].id].frame);
            if (this.effectFrames["fx"][manifest.animation.animation.sprite[index].id].dx != undefined) left = parseInt(this.effectFrames["fx"][manifest.animation.animation.sprite[index].id].dx);
            if (this.effectFrames["fx"][manifest.animation.animation.sprite[index].id].dy != undefined) top = parseInt(this.effectFrames["fx"][manifest.animation.animation.sprite[index].id].dy);
            if (this.effectFrames["fx"][manifest.animation.animation.sprite[index].id].dd != undefined) _direction = parseInt(this.effectFrames["fx"][manifest.animation.animation.sprite[index].id].dd);
          }
        }

        if (manifest.animation.animation.sprite[index].directions != 1) _direction = 0;
        const name = map.lib + "_h_" + manifest.animation.animation.sprite[index].member + "_" + _direction + "_" + frame;
        const sprite = await Assets.getSprite("HabboFigures/" + map.lib, name, flipped);
        if (sprite == null) continue;
        let directionData = null;

        for (let directionIndex in manifest.animation.animation.sprite[index].direction) {
          if (manifest.animation.animation.sprite[index].direction[directionIndex].id != direction) continue;
          directionData = manifest.animation.animation.sprite[index].direction[directionIndex];
          break;
        }

        if (directionData == null) continue;
        let asset = Figures.getEffectAsset(manifest, "h_" + manifest.animation.animation.sprite[index].member + "_" + _direction + "_" + frame);

        if (asset != null) {
          left += asset.offset.left * -1;
          top += asset.offset.top * -1;
        }

        if (flipped) left += asset.offset.left - sprite.width + 64;
        sprites.push({
          base: manifest.animation.animation.sprite[index].id,
          image: sprite,
          left: left + 96,
          top: top + 170,
          composite: Figures.getEffectComposite(manifest.animation.animation.sprite[index].ink),
          index: directionData.dz != undefined ? parseInt(directionData.dz) : 0
        });
      }
    }

    if (manifest.animation.animation.remove != undefined) {
      if (manifest.animation.animation.remove.length == undefined) manifest.animation.animation.remove = [manifest.animation.animation.remove];

      for (let index in manifest.animation.animation.remove) this.effectRemovals[manifest.animation.animation.remove[index].id] = true;
    }

    if (manifest.animation.animation.add != undefined) {
      if (manifest.animation.animation.add.length == undefined) manifest.animation.animation.add = [manifest.animation.animation.add];

      for (let index in manifest.animation.animation.add) {
        const add = manifest.animation.animation.add[index];
        let frame = 0,
            left = 0,
            top = 0,
            base = add.id;
        if (add.base != undefined) base = add.base;

        if (this.effectFrames["fx"] != undefined) {
          if (this.effectFrames["fx"][base] != undefined) {
            if (this.effectFrames["fx"][base].frame != undefined) frame = parseInt(this.effectFrames["fx"][base].frame);
            if (this.effectFrames["fx"][base].dx != undefined) left = parseInt(this.effectFrames["fx"][base].dx);
            if (this.effectFrames["fx"][base].dy != undefined) top = parseInt(this.effectFrames["fx"][base].dy);
          }
        }

        const name = "h_std_" + base + "_1_" + direction + "_" + frame;
        const sprite = await Assets.getSprite("HabboFigures/" + map.lib, map.lib + "_" + name, flipped);
        if (sprite == null) continue;
        const asset = Figures.getEffectAsset(manifest, name);

        if (asset != null) {
          left += asset.offset.left * -1;
          top += asset.offset.top * -1;
        }

        if (flipped) left += asset.offset.left - sprite.width + 64;
        sprites.push({
          base,
          image: sprite,
          left: left + 96,
          top: top + 170,
          index: Figures.getEffectIndex(add.align)
        });
      }
    }

    return sprites;
  }

}

;// @hash v3-4CEFF06D5259BB985EF10E8FCFD7DBA1455EBA8F
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
class FigureRenderer {
  constructor(figure, settings, canvas, color = undefined) {
    const entity = new FigureEntity(figure, settings);
    entity.events.render.push(function (sprites) {
      const context = canvas.getContext("2d");

      if (color != undefined) {
        context.fillStyle = color;
        context.fillRect(0, 0, context.canvas.width, context.canvas.height);
      }

      for (let index in sprites) {
        context.globalCompositeOperation = sprites[index].composite;
        context.drawImage(sprites[index].image, sprites[index].left, sprites[index].top);
      }
    });
    entity.process().then(function () {
      entity.render();
    });
  }

}

;// @hash v3-0E3B5682E20DF21E413A444040A5B84856C0CB0A
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class Badges {
  static async get(id) {
    if (Badges.cache[id] != undefined) return Badges.cache[id];

    if (Badges.promises[id] != undefined) {
      return new Promise(function (resolve) {
        Badges.promises[id].push(function (data) {
          resolve(data);
        });
      });
    }

    Badges.promises[id] = [];
    Badges.cache[id] = await SocketMessages.sendCall({
      OnBadgeRequest: id
    }, "OnBadgeRequest", function (result) {
      if (result.id != id) return 0;
      return 1;
    });

    for (let index in Badges.promises[id]) Badges.promises[id][index](Badges.cache[id]);

    return Badges.cache[id];
  }

}

_defineProperty(Badges, "cache", {});

_defineProperty(Badges, "promises", {});

;// @hash v3-2DF015F05981626FBCE48BB32E3DC0BCF02E74F8
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
class BadgeRenderer {
  constructor(id) {
    const element = document.createElement("div");
    element.classList.add("badge");
    const image = document.createElement("img");
    image.classList.add("badge-image");
    image.src = `assets/HabboBadges/${id}.gif`;
    element.appendChild(image);
    Badges.get(id).then(function () {});
    return element;
  }

}

;// @hash v3-960A8BA6AFE3B4B3128399A11E69C7680CA8100F
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class Furnitures {
  static async get(id) {
    if (Furnitures.cache[id] != undefined) return Furnitures.cache[id];

    if (Furnitures.promises[id] != undefined) {
      return new Promise(function (resolve) {
        Furnitures.promises[id].push(function (data) {
          resolve(data);
        });
      });
    }

    Furnitures.promises[id] = [];
    Furnitures.cache[id] = await SocketMessages.sendCall({
      OnFurnitureRequest: id
    }, "OnFurnitureRequest", function (result) {
      if (result.id != id) return 0;
      return 1;
    });

    for (let index in Furnitures.promises[id]) Furnitures.promises[id][index](Furnitures.cache[id]);

    return Furnitures.cache[id];
  }

  getComposite(ink) {
    switch (ink) {
      case "ADD":
        return "lighter";

      case "SUBTRACT":
        return "luminosity";

      case "COPY":
        return "source-over";

      case undefined:
        return "source-over";

      default:
        return ink;
    }
  }

}

_defineProperty(Furnitures, "cache", {
  HabboRoomCursor: {}
});

_defineProperty(Furnitures, "layers", {});

_defineProperty(Furnitures, "promises", {});

;// @hash v3-C01325F330ED61CDDC91A1B6A54D1884707B9EC2
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
const FurnitureFlags = {
  stackable: 1 << 0,
  sitable: 1 << 1,
  standable: 1 << 2,
  walkable: 1 << 3,
  sleepable: 1 << 4
};// @hash v3-3FAB88669445CC237E433DAA08CF544FFFDB1D23
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class FurnitureEntity {
  constructor(settings = {}) {
    _defineProperty(this, "settings", {
      id: null,
      library: null,
      size: 64,
      direction: null,
      animation: 0
    });

    _defineProperty(this, "events", {
      render: []
    });

    this.update(settings);
  }

  async render() {
    // const layerName = this.types.type + "_" + this.settings.size + "_" + this.settings.animation + "_" + this.settings.direction + "_" + JSON.stringify(this.animations);
    //console.error(layerName);
    //if(Furnitures.layers[layerName] == undefined) {
    const layers = this.getLayers();
    const sprites = [];

    for (let index in layers) {
      const layer = layers[index];
      const frame = this.getVisualizationAnimationLayer(index);
      const name = this.getLayerName(this.types.type, this.settings.size, index, this.settings.direction, frame);

      if (Furnitures.layers[name] == undefined) {
        layer.asset = this.getLayerAsset(name);

        if (layer.asset == null) {
          delete layers[index];
          continue;
        }

        layer.sprite = await Assets.getSprite(this.library, layer.asset.name, layer.asset.flipH == 1 ? true : false);

        if (layer.sprite == null) {
          delete layers[index];
          continue;
        }

        layer.spriteData = await Assets.getSpriteData(this.library, layer.asset.name + (layer.asset.flipH == 1 ? "?flipped=true" : ""));
        layer.z = layer.z == undefined ? 0 : parseInt(layer.z);
        layer.ink = layer.ink == undefined ? "source-over" : this.getLayerInk(layer.ink);
        layer.alpha = layer.alpha == undefined ? 1.0 : parseInt(layer.alpha) / 100;
        layer.asset.x = layer.asset.x == undefined ? 0 : parseInt(layer.asset.x);
        layer.asset.y = layer.asset.y == undefined ? 0 : parseInt(layer.asset.y);
        if (layer.asset.flipH == 1) layer.asset.x = layer.asset.x * -1 + layer.sprite.width;
        Furnitures.layers[name] = layer;
      }

      sprites.push(Furnitures.layers[name]);
    }

    sprites.sort(function (a, b) {
      return a.z - b.z;
    }); //Furnitures.layers[layerName] = sprites;
    //}

    for (let index in this.events.render) this.events.render[index](sprites);
  }

  getLayers() {
    const layerCount = parseInt(this.visualization.layerCount);
    const layers = this.getVisualizationLayers();
    const directions = this.getVisualizationDirectionLayers(this.settings.direction);

    for (let key in directions) {
      if (layers[key] == undefined) layers[key] = {};

      for (let property in directions[key]) layers[key][property] = directions[key][property];
    }

    for (let index = 0; index < layerCount; index++) {
      if (layers[index] == undefined) layers[index] = {};
    }

    return layers;
  }

  getLayerName(id, size, layer, direction, frame) {
    if (size == 1) return id + "_icon_" + Client.utils.charCode(parseInt(layer));
    return id + "_" + size + "_" + Client.utils.charCode(parseInt(layer)) + "_" + direction + "_" + frame;
  }

  getLayerInk(ink) {
    switch (ink) {
      case "ADD":
        return "lighter";

      case "SUBTRACT":
        return "luminosity";
      //case "COPY": return "source-over";

      default:
        return ink;
    }
  }

  getLayerAsset(name) {
    for (let index in this.manifest.assets.assets.asset) {
      const asset = JSON.parse(JSON.stringify(this.manifest.assets.assets.asset[index]));
      if (asset.name != name) continue;

      if (asset.source != undefined && asset.source != asset.name) {
        const sourceAsset = this.getLayerAsset(asset.source);
        delete asset.source;

        for (let key in sourceAsset) {
          if (asset[key] == undefined) asset[key] = sourceAsset[key];
        }

        asset.name = sourceAsset.name;
      }

      return asset;
    }

    return null;
  }

  getVisualization() {
    const data = this.manifest.visualization.visualizationData;
    const visualization = data.graphics != undefined ? data.graphics.visualization : data.visualization;

    for (let index in visualization) {
      if (visualization[index].size == this.settings.size) return visualization[index];
    }

    return null;
  }

  getVisualizationLayers() {
    const layers = {};
    if (this.visualization.layers == undefined) return {};
    if (this.visualization.layers.layer.length == undefined) this.visualization.layers.layer = [this.visualization.layers.layer];

    for (let index in this.visualization.layers.layer) {
      const layer = this.visualization.layers.layer[index];
      layers[layer.id] = {};

      for (let key in layer) {
        if (key == "id") continue;
        layers[layer.id][key] = layer[key];
      }
    }

    return layers;
  }

  getVisualizationDirectionLayers() {
    if (this.visualization.directions == undefined) return {};
    if (this.visualization.directions.direction.length == undefined) this.visualization.directions.direction = [this.visualization.directions.direction];

    for (let index in this.visualization.directions.direction) {
      if (this.visualization.directions.direction[index].id != this.settings.direction) continue;
      const directions = this.visualization.directions.direction[index];
      if (directions.layer == undefined) return {};
      if (directions.layer.length == undefined) directions.layer = [directions.layer];
      const layers = {};

      for (let index in directions.layer) {
        const layer = directions.layer[index];
        layers[layer.id] = {};

        for (let key in layer) {
          if (key == "id") continue;
          layers[layer.id][key] = layer[key];
        }
      }

      return layers;
    }

    return {};
  }

  getVisualizationAnimation() {
    if (this.visualization.animations == null || this.visualization.animations == undefined) return undefined;

    if (this.settings.animation != 0) {
      if (this.types.logic == "furniture_score") {
        const layers = {};
        let layer = 2;

        for (let index = 1; index <= 100; index *= 10) {
          layers["" + layer] = {
            frameSequence: [Math.floor(this.settings.animation / index % 10)],
            frameRepeat: 0,
            frameRepeatSequence: 0,
            frameLoop: 0,
            frameTransition: undefined,
            frame: 0
          };
          layer++;
        }

        return layers;
      } else if (this.types.logic == "furniture_counter_clock") {
        const layers = {};
        const minutes = Math.floor(this.settings.animation / 60);
        const seconds = this.settings.animation - minutes * 60;
        layers["" + 6] = {
          frameSequence: [Math.floor(seconds / 1 % 10)],
          frameRepeat: 0,
          frameRepeatSequence: 0,
          frameLoop: 0,
          frameTransition: undefined,
          frame: 0
        };
        layers["" + 7] = {
          frameSequence: [Math.floor(seconds / 10 % 10)],
          frameRepeat: 0,
          frameRepeatSequence: 0,
          frameLoop: 0,
          frameTransition: undefined,
          frame: 0
        };
        layers["" + 8] = {
          frameSequence: [Math.floor(minutes / 1 % 10)],
          frameRepeat: 0,
          frameRepeatSequence: 0,
          frameLoop: 0,
          frameTransition: undefined,
          frame: 0
        };
        layers["" + 9] = {
          frameSequence: [Math.floor(minutes / 10 % 10)],
          frameRepeat: 0,
          frameRepeatSequence: 0,
          frameLoop: 0,
          frameTransition: undefined,
          frame: 0
        };
        return layers;
      }
    }

    for (let index in this.visualization.animations.animation) {
      if (this.visualization.animations.animation[index].id != this.settings.animation) continue;
      const animationProperties = this.visualization.animations.animation[index];
      let animationLayers = this.visualization.animations.animation[index].animationLayer;
      if (animationLayers == undefined) return undefined;
      if (animationLayers.length == undefined) animationLayers = [animationLayers];
      const layers = {};
      let layerCount = 0;

      for (let index in animationLayers) {
        const layer = animationLayers[index].id;
        if (animationLayers[index].frameSequence == undefined) continue;
        if (animationLayers[index].frameSequence.frame == undefined) continue;
        layers[layer] = {
          frameSequence: [],
          frameRepeat: animationLayers[index].frameRepeat != undefined ? parseInt(animationLayers[index].frameRepeat) : 0,
          frameRepeatSequence: 0,
          frameLoop: animationLayers[index].loopCount != undefined ? parseInt(animationLayers[index].loopCount) : 0,
          frameTransition: animationProperties.transitionTo != undefined ? parseInt(animationProperties.transitionTo) : undefined,
          frame: 0
        };
        if (animationLayers[index].frameSequence.frame.length == undefined) animationLayers[index].frameSequence.frame = [animationLayers[index].frameSequence.frame];

        for (let frame in animationLayers[index].frameSequence.frame) layers[layer].frameSequence.push(animationLayers[index].frameSequence.frame[frame].id);

        layerCount++;
      }

      if (layerCount == 0) return undefined;
      return layers;
    }

    if (this.settings.animation >= 100) {
      this.settings.animation -= 100;
      this.animations = this.getVisualizationAnimation();
      return this.animations;
    }

    return undefined;
  }

  getVisualizationAnimationLayer(layer) {
    if (this.animations == undefined || this.animations[layer] == undefined) return 0;
    return this.animations[layer].frameSequence[this.animations[layer].frame];
  }

  getDimensions() {
    const result = {
      row: 0,
      column: 0,
      depth: 0
    };
    const data = this.manifest.logic.objectData.model.dimensions;
    if (data.x != undefined) result.row = parseFloat(data.x);
    if (data.y != undefined) result.column = parseFloat(data.y);
    if (data.z != undefined) result.depth = parseFloat(data.z);

    if (this.settings.direction == 0 || this.settings.direction == 4) {
      const spare = result.row;
      result.row = result.column;
      result.column = spare;
    }

    return result;
  }

  getDirection(direction = this.settings.direction) {
    const directions = this.manifest.logic.objectData.model.directions;
    if (directions == undefined) return 0;
    if (directions.direction.length == undefined) directions.direction = [directions.direction];

    for (let index in directions.direction) {
      if (this.getDirectionAngle(directions.direction[index].id) != direction) continue;
      return direction;
    }

    return this.getDirectionAngle(directions.direction[0].id);
  }

  getNextDirection(direction = this.settings.direction) {
    const directions = this.manifest.logic.objectData.model.directions;
    if (directions == undefined) return direction;
    if (directions.direction.length == undefined) directions.direction = [directions.direction];

    for (let index in directions.direction) {
      if (this.getDirectionAngle(directions.direction[index].id) != direction) continue;
      if (directions.direction[parseInt(index) + 1] == undefined) return this.getDirectionAngle(directions.direction[0].id);
      return this.getDirectionAngle(directions.direction[parseInt(index) + 1].id);
    }

    return this.getDirectionAngle(directions.direction[0].id);
  }

  getDirectionAngle(angle) {
    return Math.floor(parseInt(angle) / 45);
  }

  async update(settings) {
    if (settings.id != undefined && settings.id == "HabboRoomCursor") settings.library = settings.id;

    for (let key in settings) this.settings[key] = settings[key];
  }

  getNextAnimation(animation = this.settings.animation) {
    const animations = this.visualization.animations;
    if (animations == undefined) return 0;
    if (animations.animation.length == undefined) animations.animation = [animations.animation];

    for (let index in animations.animation) {
      if (animations.animation[index].id != animation) continue;
      if (animations.animation[parseInt(index) + 1] == undefined) return parseInt(animations.animation[0].id);
      return parseInt(animations.animation[parseInt(index) + 1].id);
    }

    return parseInt(animations.animation[0].id);
  }

  updateAnimations(timestamp = performance.now()) {
    let updated = false;
    if (this.animations == undefined) return false;

    for (let index in this.animations) {
      if (!(timestamp - this.animationTimestamps[index] > 1000 / 12)) continue;

      if (this.animations[index].frameRepeatSequence != this.animations[index].frameRepeat) {
        this.animations[index].frameRepeatSequence++;
        continue;
      }

      this.animations[index].frameRepeatSequence = 0;
      const previousFrame = this.animations[index].frame;
      this.animations[index].frame++;

      if (this.animations[index].frame >= this.animations[index].frameSequence.length) {
        this.animations[index].frame = 0;

        if (this.animations[index].frameTransition != undefined) {
          this.setAnimation(this.animations[index].frameTransition);
          return true;
        }
      }

      this.animationTimestamps[index] = timestamp;
      if (this.animations[index].frameSequence[previousFrame] != this.animations[index].frameSequence[this.animations[index].frame]) updated = true;
    }

    return updated;
  }

  setAnimation(animation) {
    this.settings.animation = animation;

    if (this.types.logic == "furniture_score") {}

    this.animations = this.getVisualizationAnimation();
    this.animationTimestamps = {};

    for (let index in this.animations) this.animationTimestamps[index] = 0;

    this.render();
  }

  setDirection(direction) {
    this.settings.direction = this.getDirection(direction);
  }

  async process() {
    this.furniture = await Furnitures.get(this.settings.id);
    this.library = this.settings.library != null ? this.settings.library : "HabboFurnitures/" + this.furniture.line + "/" + this.furniture.id;
    this.manifest = await Assets.getManifest(this.library);
    this.visualization = this.getVisualization();
    this.types = this.manifest.index.object;
    if (this.settings.animation != undefined) this.setAnimation(this.settings.animation);
    this.settings.direction = this.getDirection();
  }

}

;// @hash v3-6A7C9D16B0BF8B4D28899CD23FE24C88FD14332B
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
class FurnitureRenderer {
  constructor(settings, canvas, color = undefined) {
    this.settings = settings;
    this.canvas = canvas;
    this.color = color;
    this.renderer();
  }

  async renderer() {
    const loading = await Assets.getSpritesheet(this.settings.size == 1 ? "HabboLoadingIcon" : "HabboLoading").then(image => {
      const context = this.canvas.getContext("2d");
      context.canvas.width = image.width;
      context.canvas.height = image.height;
      context.drawImage(image, 0, 0);
    });
    const entity = new FurnitureEntity(this.settings);
    entity.events.render.push(sprites => {
      const context = this.canvas.getContext("2d");
      let minLeft = 0,
          minTop = 0,
          maxWidth = 0,
          maxHeight = 0;

      for (let index in sprites) {
        if (minLeft > sprites[index].asset.x * -1) minLeft = sprites[index].asset.x * -1;
        if (minTop > sprites[index].asset.y * -1) minTop = sprites[index].asset.y * -1;
        if (sprites[index].asset.x * -1 + sprites[index].sprite.width > maxWidth) maxWidth = sprites[index].asset.x * -1 + sprites[index].sprite.width;
        if (sprites[index].asset.y * -1 + sprites[index].sprite.height > maxHeight) maxHeight = sprites[index].asset.y * -1 + sprites[index].sprite.height;
      }

      context.canvas.width = minLeft * -1 + maxWidth;
      context.canvas.height = minTop * -1 + maxHeight;

      if (this.color != undefined) {
        context.fillStyle = this.color;
        context.fillRect(0, 0, context.canvas.width, context.canvas.height);
      }

      for (let index in sprites) {
        context.globalCompositeOperation = sprites[index].ink;
        context.drawImage(sprites[index].sprite, minLeft * -1 - sprites[index].asset.x, minTop * -1 - sprites[index].asset.y);
      }
    });
    entity.process().then(async () => {
      await entity.render();

      if (entity.types.visualization == "furniture_animated") {
        setInterval(() => {
          const timestamp = performance.now();
          if (!entity.updateAnimations(timestamp)) return;
          entity.render();
        }, 1000 / 12);
        this.canvas.addEventListener("click", () => {
          entity.setAnimation(entity.getNextAnimation());
        });
      }
    });
  }

}

;// @hash v3-D8555615CF3606BEDACF16965D24947E0B5624FC
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
class Canvas {
  constructor(canvas, settings = {}) {
    this.canvas = canvas;
    this.enabled = settings.enabled ?? true;
    this.offset = settings.offset ?? {
      left: 0,
      top: 0
    };
    this.draggable = settings.draggable ?? true;
    this.draggableEnabled = settings.draggableEnabled ?? false;
    this.draggableRate = settings.draggableRate ?? 0;
    this.draggableTimestamp = settings.draggableTimestamp ?? 0;
    this.frame = settings.frame ?? 0;
    this.frameRate = settings.frameRate ?? 24;
    this.frameTimestamp = settings.frameTimestamp ?? 0;
    this.frameLogs = settings.frameLogs ?? [];

    if (this.draggable) {
      let position = null;
      this.canvas.addEventListener("mouseenter", event => {
        this.frameRate = 0;
      });
      this.canvas.addEventListener("mouseleave", event => {
        this.frameRate = 24;
      });
      this.canvas.addEventListener("mousedown", event => {
        if (Keys.down["ShiftLeft"]) return;
        this.draggableEnabled = true;
        this.draggableTimestamp = performance.now();
        position = {
          left: event.offsetX,
          top: event.offsetY
        };
      });
      this.canvas.addEventListener("mouseup", () => {
        this.draggableEnabled = false;
      });
      this.canvas.addEventListener("mousemove", event => {
        if (this.draggableEnabled == false) return;
        this.offset.left += event.offsetX - position.left;
        this.offset.top += event.offsetY - position.top;
        position = {
          left: event.offsetX,
          top: event.offsetY
        };
      });
    }

    CanvasManager.list.push(this);
  }

  getContext(context) {
    return this.canvas.getContext(context);
  }

  start() {
    this.enabled = true;
  }

  destroy() {
    this.enabled = false;
  }

  stop() {
    this.enabled = false;
  }

}

;// @hash v3-477EB62B61C5790AFC70510F439C072EEC3C2332
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
var _temp;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const CanvasManager = new (_temp = class {
  constructor() {
    _defineProperty(this, "list", []);

    this.render();
  }

  render() {
    window.requestAnimationFrame(() => {
      const timestamp = performance.now();

      for (let index = 0; index < this.list.length; index++) {
        try {
          if (this.list[index].enabled == false) continue;
          if (this.list[index].render == undefined) continue;

          if (this.list[index].draggableEnabled == false && this.list[index].frameRate != 0 || this.list[index].draggableEnabled == true && this.list[index].draggableRate != 0) {
            const delta = timestamp - this.list[index].frameTimestamp;
            const interval = 1000 / this.list[index].frameRate;
            if (delta < interval) continue;
            this.list[index].frameTimestamp = timestamp - delta % interval;
          }

          this.list[index].frame++;
          if (this.list[index].frame == this.list[index].frameRate + 1) this.list[index].frame = 1;

          for (let log in this.list[index].frameLogs) if (timestamp - this.list[index].frameLogs[log] >= 1000) this.list[index].frameLogs.splice(log, 1);

          this.list[index].frameLogs.push(timestamp);
          this.list[index].render(this.list[index]);
          const context = this.list[index].canvas.getContext("2d");
          context.resetTransform();
          context.font = "13px Ubuntu Regular";
          context.fillStyle = "rgba(255, 255, 255, .5)";
          context.textAlign = "right";
          context.fillText(`Canvas ${index}: ${this.list[index].frameLogs.length} FPS`, context.canvas.width - 12, context.canvas.height - 100);
        } catch {}
      }

      this.render();
    });
  }

}, _temp)();// @hash v3-771610C9461F4B92C0490175EEC5114C2C529404
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
Client.rooms = new function () {
  this.items = new function () {}();
}();// @hash v3-E2C84DEBC8E98A536FD5DF83A2B1A03F6B413772
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class RoomEntity {
  constructor(parent) {
    _defineProperty(this, "background", "#111");

    _defineProperty(this, "center", 0);

    _defineProperty(this, "entities", []);

    _defineProperty(this, "currentEntity", undefined);

    _defineProperty(this, "sprites", []);

    _defineProperty(this, "events", {
      render: [],
      beforeRender: []
    });

    this.parent = parent;
    const canvas = document.createElement("canvas");
    parent.append(canvas);
    this.canvas = new Canvas(canvas, {
      enabled: false
    });

    this.canvas.render = () => this.render();
  }

  setOffset(left, top) {
    this.canvas.offset = {
      left,
      top
    };
  }

  addEntity(entity) {
    this.entities.push(entity);
    return entity;
  }

  getEntity(position, type = null) {
    if (position == undefined) return undefined;
    const offset = [position[0] - this.canvas.offset.left - this.center, position[1] - this.canvas.offset.top];
    const sprites = type == null ? this.sprites : this.sprites.filter(x => x.parent.name == type);

    for (let index = sprites.length - 1; index != -1; index--) {
      const mouseover = sprites[index].mouseover(offset, this.center);
      if (mouseover == false) continue;
      return {
        entity: sprites[index].parent,
        sprite: sprites[index],
        result: mouseover
      };
    }

    return undefined;
  }

  removeEntity(entity) {
    const index = this.entities.indexOf(entity);
    if (index == -1) return;
    this.entities.splice(index, 1);
  }

  updateCanvas() {
    const width = this.parent.clientWidth;
    const height = this.parent.clientHeight;
    this.canvas.canvas.width = width;
    this.canvas.canvas.height = height;
    /*.css({
        "width": Math.floor(width * window.devicePixelRatio),
        "height": Math.floor(height * window.devicePixelRatio)
    })*/
  }

  render() {
    let timestamp = performance.now();

    for (let index = 0; index < this.entities.length; index++) this.entities[index].process(timestamp, this.canvas.frame);

    this.updateCanvas();

    for (let index = 0; index < this.events.beforeRender.length; index++) this.events.beforeRender[index]();

    const context = this.canvas.canvas.getContext("2d");
    context.fillStyle = this.background;
    context.fillRect(0, 0, context.canvas.width, context.canvas.height);
    context.save(); //context.imageSmoothingEnabled = false;
    //context.scale(window.devicePixelRatio, window.devicePixelRatio);

    this.sprites = [];

    for (let index = 0; index < this.entities.length; index++) {
      if (this.entities[index].enabled == false) continue;
      this.sprites = this.sprites.concat(this.entities[index].sprites);
    }

    this.sprites.sort(function (a, b) {
      return a.getIndex() - b.getIndex();
    });
    const offset = [this.center + this.canvas.offset.left, this.canvas.offset.top];

    for (let index = 0; index < this.sprites.length; index++) this.sprites[index].render(context, offset);

    for (let index = 0; index < this.events.render.length; index++) this.events.render[index]();

    context.restore();
    /*if(this.framePerformance.length == this.frameRate)
        this.framePerformance.shift();
      const milliseconds = (Math.round((performance.now() - timestamp) * 100) / 100);
      this.framePerformance.push(milliseconds);
      const median = Client.utils.getArrayMedian(this.framePerformance);
    
    if(median > 6) {
        //console.warn("[RoomEntity]%c Execution for last " + this.framePerformance.length + " frames took ~" + (Math.round(median * 100) / 100) + "ms; last took ~" + milliseconds + "ms!", "color: lightblue");
          //this.framePerformance.length = 0;
    }
      timestamp = performance.now();
      for(let index in this.frameRates) {
        if(timestamp - this.frameRates[index] >= 1000) {
            this.frameRates.splice(index, 1);
        }
    }
      this.frameRates.push(timestamp);
      ClientDevelopment.frames.innerText = `, ${this.frameRates.length} FPS`;*/

    return {
      median: 0,
      milliseconds: 0,
      frames: 0
    };
  }

  setCursor(cursor) {
    this.canvas.style.cursor = cursor;
  }

}

;// @hash v3-0C9C6F13EC0E9F89F023748FCFB1921AD65A14EB
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
const RoomCategories = new class {
  async get() {
    if (this.categories != undefined) return this.categories;
    this.categories = await SocketMessages.sendCall({
      OnRoomCategoriesUpdate: null
    }, "OnRoomCategoriesUpdate");
    return this.categories;
  }

}();// @hash v3-53C0AEA86B4D7D4CDBE297E9B90B74D5A44F9988
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
Client.rooms.map = new function () {
  this.getIndex = function (data, id) {
    const array = Client.rooms.asset.room_visualization.visualizationData[data + "Data"][data + "s"][data];
    let index = 0;

    for (index in array) {
      if (array[index].id != id) continue;
      break;
    }

    return index;
  };

  this.getSizes = function (data, index) {
    const array = Client.rooms.asset.room_visualization.visualizationData[data + "Data"][data + "s"][data];
    return array[index].visualization;
  };

  this.getVisualization = function (data, size) {
    let index = 0;

    for (index in data) {
      if (data[index].size != size) continue;
      break;
    }

    return data[index].visualizationLayer;
  };

  this.getMaterial = function (data, material) {
    const materials = Client.rooms.asset.room_visualization.visualizationData[data + "Data"].materials.material;
    let index = 0;

    for (index in materials) {
      if (materials[index].id != material) continue;
      break;
    }

    return materials[index].materialCellMatrix.materialCellColumn;
  };

  this.getTexture = function (data, texture) {
    const textures = Client.rooms.asset.room_visualization.visualizationData[data + "Data"].textures.texture;
    let index = 0;

    for (index in textures) {
      if (textures[index].id != texture) continue;
      break;
    }

    return "HabboRoomContent_" + textures[index].bitmap.assetName;
  };

  this.getAsset = function (name) {
    const assets = Client.rooms.asset.room_assets.assets.asset;
    let index = 0;

    for (index in assets) {
      if (assets[index].name == name) break;
    }

    const asset = JSON.parse(JSON.stringify(assets[index]));

    if (asset.source != undefined) {
      const source = this.getAsset(asset.source);

      for (let key in source) if (asset[key] == undefined) asset[key] = source[key];
    }

    return asset;
  };

  this.getMask = function (name) {
    const asset = this.getAsset(name);
    return {
      asset
    };
  };
}();// @hash v3-4658DE9039FDE7C2C3571CD17DCD475D90E67380
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
Client.rooms.map.entity = function (map, door = {}, floor = {}, wall = {}) {
  this.settings = {
    map: map,
    door: {
      row: null,
      column: null
    },
    floor: {
      material: "default",
      thickness: 8
    },
    wall: {
      material: "default",
      thickness: 8
    }
  };

  this.render = async function () {
    this.rows = this.settings.map.length;
    this.columns = 0;
    this.depth = 0;

    for (let row in this.settings.map) if (this.settings.map[row].length > this.columns) this.columns = this.settings.map[row].length;

    this.map = {};

    for (let row in this.settings.map) {
      this.map[row] = {};

      for (let column in this.settings.map[row]) {
        this.map[row][column] = this.settings.map[row][column];
        if (this.map[row][column] == 'X') continue;
        if (!Client.utils.isLetter(this.map[row][column])) this.map[row][column] = parseInt(this.map[row][column]);else this.map[row][column] = Client.utils.fromCharCode(this.map[row][column]);
        if (this.map[row][column] > this.depth) this.depth = this.map[row][column];
      }
    }

    if (this.getCoordinate(door.row + 1, door.column) == 'X' && this.getCoordinate(door.row - 1, door.column) == 'X') this.settings.door = door;
    await this.renderFloor();
    await this.renderWall();
  };

  this.renderPatterns = async function (type, id) {
    const index = Client.rooms.map.getIndex(type, id);
    const sizes = Client.rooms.map.getSizes(type, index);
    const visualization = Client.rooms.map.getVisualization(sizes, 64);
    const material = Client.rooms.map.getMaterial(type, visualization.materialId);
    const texture = Client.rooms.map.getTexture(type, material.materialCell.textureId);
    let canvas,
        context,
        patterns = [];
    canvas = await Assets.getSpriteColor("HabboRoomContent", texture, visualization.color);
    context = canvas.getContext("2d");
    patterns[0] = context.createPattern(canvas, "repeat");
    canvas = await Assets.getSpriteColor("HabboRoomContent", texture + "?color=" + visualization.color, "#666");
    context = canvas.getContext("2d");
    patterns[1] = context.createPattern(canvas, "repeat");
    canvas = await Assets.getSpriteColor("HabboRoomContent", texture + "?color=" + visualization.color, "#BBB");
    context = canvas.getContext("2d");
    patterns[2] = context.createPattern(canvas, "repeat");
    return patterns;
  };

  this.renderFloor = async function () {
    const patterns = await this.renderPatterns("floor", this.settings.floor.material); // TODO: check if the +10 is actually needed

    const width = this.rows * 32 + this.columns * 32;
    const height = this.rows * 16 + this.columns * 16 + this.settings.floor.thickness + this.depth * 16 + 10;
    this.floor = [];
    this.floorCanvas = document.createElement("canvas");
    this.floorCanvas.width = width;
    this.floorCanvas.height = height;
    const allRectangles = [];

    for (let row in this.map) {
      for (let column in this.map[row]) {
        const tile = this.getCoordinate(row, column, true);
        if (tile == 'X') continue;

        if (this.getCoordinate(row, parseInt(column) - 1) == tile + 1) {
          for (let step = 0; step < 4; step++) {
            allRectangles.push({
              row,
              column: parseInt(column) + step * .25,
              depth: tile + 0.75 - step * .25,
              width: 8,
              height: 32
            });
          }

          continue;
        }

        if (this.getCoordinate(parseInt(row) - 1, column) == tile + 1) {
          for (let step = 0; step < 4; step++) {
            allRectangles.push({
              row: parseInt(row) + step * .25,
              column,
              depth: tile + 0.75 - step * .25,
              width: 32,
              height: 8
            });
          }

          continue;
        }

        allRectangles.push({
          row,
          column,
          depth: tile,
          width: 32,
          height: 32
        });
      }
    }

    const context = this.floorCanvas.getContext("2d");

    for (let _depth = 0; _depth <= this.depth; _depth++) {
      const rectangles = allRectangles.filter(x => Math.ceil(x.depth) == _depth);
      if (rectangles.length == 0) continue;
      context.beginPath();
      context.setTransform(1, .5, 0, 1, this.settings.wall.thickness + this.rows * 32, this.depth * 16);
      context.fillStyle = patterns[2];

      for (let index in rectangles) {
        const rectangle = rectangles[index];
        if (rectangles.find(x => parseInt(x.row) == parseInt(rectangle.row) + 1 && x.column == rectangle.column && x.depth == rectangle.depth) != null) continue;
        const left = rectangle.column * 32 - rectangle.row * 32 - rectangle.height;
        const top = rectangle.row * 32 - rectangle.depth * 32 + rectangle.height;
        context.rect(left, top, rectangle.width, this.settings.floor.thickness);
      }

      context.fill();
      context.beginPath();
      context.setTransform(1, -.5, 0, 1, this.settings.wall.thickness + this.rows * 32, this.depth * 16);
      context.fillStyle = patterns[1];

      for (let index in rectangles) {
        const rectangle = rectangles[index];
        if (rectangles.find(x => x.row == rectangle.row && parseInt(x.column) == parseInt(rectangle.column) + 1 && x.depth == rectangle.depth) != null) continue;
        const row = parseFloat(rectangle.row);
        const column = parseFloat(rectangle.column);
        const left = -(row * 32) + column * 32 + rectangle.width - rectangle.height;
        const top = column * 32 - rectangle.depth * 32 + rectangle.width;
        context.rect(left, top, rectangle.height, this.settings.floor.thickness);
      }

      context.fill();
      context.beginPath();
      context.setTransform(1, .5, -1, .5, this.settings.wall.thickness + this.rows * 32, this.depth * 16);
      context.fillStyle = patterns[0];
      const tiles = new Path2D();

      for (let index in rectangles) {
        const rectangle = rectangles[index];
        const left = rectangle.column * 32 - rectangle.depth * 32;
        const top = rectangle.row * 32 - rectangle.depth * 32;
        const path = new Path2D();
        path.rect(left, top, rectangle.width, rectangle.height);
        this.floor.push({
          row: rectangle.row,
          column: rectangle.column,
          depth: rectangle.depth,
          path
        });
        tiles.addPath(path);
      }

      context.fill(tiles);
    }
  };

  this.renderWall = async function () {
    const patterns = await this.renderPatterns("wall", this.settings.wall.material);
    const context = this.wallCanvas.getContext("2d");
    context.canvas.width = this.rows * 32 + this.columns * 32 + 2 * this.settings.floor.thickness;
    context.canvas.height = this.rows * 32 + this.columns * 16 + this.depth * 16 + this.settings.floor.thickness;
    const rectangles = [];

    for (let row in this.map) {
      for (let column in this.map[row]) {
        const depth = this.getCoordinate(row, column, true);
        if (depth == 'X') continue;
        if (this.settings.door.row == row && this.settings.door.column == column) continue;
        let hasPrevious = false;

        for (let previousRow = row - 1; previousRow >= 0; previousRow--) {
          if (this.getCoordinate(previousRow, column, true) == 'X') {
            for (let previousColumn = column - 1; previousColumn >= 0; previousColumn--) {
              if (this.getCoordinate(previousRow, previousColumn, true) == 'X') continue;
              hasPrevious = true;
              break;
            }

            if (hasPrevious) break;
            continue;
          }

          hasPrevious = true;
          break;
        }

        if (hasPrevious) continue;
        rectangles.push({
          row: parseInt(row),
          column: parseInt(column),
          depth,
          direction: 4
        });
      }
    }

    for (let row in this.map) {
      for (let column in this.map[row]) {
        const depth = this.getCoordinate(row, column, true);
        if (depth == 'X') continue;
        let hasPrevious = false;

        for (let previousColumn = column - 1; previousColumn >= 0; previousColumn--) {
          if (this.getCoordinate(row, previousColumn, true) != 'X') {
            hasPrevious = true;
            break;
          }

          for (let previousRow = row - 1; previousRow >= 0; previousRow--) {
            if (this.getCoordinate(previousRow, previousColumn, true) != 'X') {
              hasPrevious = true;
              break;
            }
          }
        }

        if (hasPrevious) continue;
        rectangles.push({
          row: parseInt(row),
          column: parseInt(column),
          depth,
          direction: 2
        });
      }
    }

    const rectanglesLeft = rectangles.filter(x => x.direction == 4);

    for (let index in rectanglesLeft) {
      const rectangle = rectanglesLeft[index];
      if (rectangles.find(x => x.direction == 2 && x.row == rectangle.row && x.column == rectangle.column) == null) continue;
      rectangles.push({
        row: rectangle.row,
        column: rectangle.column,
        depth: rectangle.depth,
        direction: 1
      });
    }

    this.offset = -((this.depth + 3.5) * 32);
    context.beginPath();
    context.setTransform(1, -.5, 0, 1, this.settings.wall.thickness + this.rows * 32, this.depth * 16);
    context.fillStyle = patterns[1];

    for (let index in rectangles) {
      const rectangle = rectangles[index];
      let width = 32;
      let height = (3.5 + (this.depth - rectangle.depth)) * 32;
      let row = rectangle.row;
      let column = rectangle.column;

      if (rectangle.direction == 4) {
        column++;
        if (this.getCoordinate(row, column) != 'X') continue;
        width = this.settings.wall.thickness;
        height += this.settings.floor.thickness;
      } else if (rectangle.direction == 2) {
        row++;
      } else continue;

      const left = -(row * 32) + column * 32;
      const top = column * 32 - this.depth * 16;
      context.rect(left, top, width, height);
    }

    context.fill();
    context.closePath();
    context.beginPath();
    context.setTransform(1, .5, 0, 1, this.settings.wall.thickness + this.rows * 32, this.depth * 16);
    context.fillStyle = patterns[2];

    for (let index in rectangles) {
      const rectangle = rectangles[index];
      let row = rectangle.row;
      let column = rectangle.column;
      let width = 32;
      let height = (3.5 + (this.depth - rectangle.depth)) * 32;

      if (rectangle.direction == 4) {} else if (rectangle.direction == 2) {
        row++;
        if (this.getCoordinate(row, column) != 'X') continue;
        width = this.settings.wall.thickness;
        height += this.settings.floor.thickness;
      } else continue;

      let left = column * 32 - row * 32;
      let top = row * 32 - this.depth * 16;
      context.rect(left - (width == 32 ? 0 : this.settings.wall.thickness), top, width, height);
    }

    context.fill();
    context.closePath();
    context.beginPath();
    context.setTransform(1, .5, -1, .5, this.settings.wall.thickness + this.rows * 32, this.depth * 16);
    context.fillStyle = patterns[0];

    for (let index in rectangles) {
      const rectangle = rectangles[index];
      let row = rectangle.row;
      let column = rectangle.column;
      let width = 32;
      let height = 32;
      let left = column * 32 - this.depth * 16;
      let top = row * 32 - this.depth * 16;

      if (rectangle.direction == 1) {
        width = this.settings.wall.thickness;
        height = this.settings.wall.thickness;
        left -= this.settings.wall.thickness;
        top -= this.settings.wall.thickness;
      } else if (rectangle.direction == 2) {
        width = this.settings.wall.thickness;
        left -= this.settings.wall.thickness;
      } else if (rectangle.direction == 4) {
        height = this.settings.wall.thickness;
        top -= this.settings.wall.thickness;
      } else continue;

      context.rect(left, top, width, height);
    }

    context.fill();
    context.closePath();

    if (this.settings.door.row != null && this.settings.door.column != null) {
      const mask = Client.rooms.map.getMask("door_64");
      const sprite = await Assets.getSprite("HabboRoomContent", "HabboRoomContent_" + mask.asset.name);
      context.globalCompositeOperation = "destination-out";
      context.setTransform(1, -.5, 0, 1, this.settings.wall.thickness + this.rows * 32, this.depth * 16);
      const row = this.settings.door.row;
      const column = this.settings.door.column;
      const depth = this.getCoordinate(row, column);
      const left = -(row * 32) + column * 32;
      const top = this.settings.wall.thickness / 2 + column * 32 - this.depth * 16 + (3.5 + (this.depth - depth)) * 32 + 32 - sprite.height;
      context.drawImage(sprite, left, top);
    }
  };

  this.getCoordinate = function (row, column, door = false) {
    if (door && this.settings.door.row == row && this.settings.door.column == column) {
      if (this.getCoordinate(row + 1, column) == 'X') return 'X';
    }

    if (this.map[row] == undefined || this.map[row][column] == undefined) return 'X';
    return this.map[row][column];
  };

  for (let key in floor) this.settings.floor[key] = floor[key];

  for (let key in wall) this.settings.wall[key] = wall[key];

  this.wallCanvas = document.createElement("canvas");
};// @hash v3-09046FA7D571DD6985A82E415BF6382035346C28
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
Client.rooms.items.entity = function (parent, name) {
  this.events = new function () {
    this.path = {
      start: [],
      frame: [],
      finish: []
    };
  }();
  this.parent = parent;
  this.name = name;
  this.index = 0;
  this.alpha = 1.0;
  this.sprites = [];
  this.data = {};
  this.offset = [0, 0];

  this.getOffset = function () {
    return [this.offset[0], this.offset[1]];
  };

  this.path = false;

  this.setPath = function (from, to, ticks = 500) {
    this.path = true;
    this.pathFrame = 0;
    this.pathFrames = Math.floor(24 / 1000 * ticks);
    this.pathLastFrame = -1;
    this.pathTick = performance.now();
    this.pathTicks = ticks;
    this.pathFrom = from;
    this.pathTo = to;
    this.pathDifference = {
      row: to.row - from.row,
      column: to.column - from.column,
      depth: to.depth - from.depth
    };

    for (let index in this.events.path.start) this.events.path.start[index]();
  };

  this.stopPath = function (finish = true) {
    if (this.path == false) return;
    this.path = false;
    if (finish) this.setCoordinates(this.pathTo.row, this.pathTo.column, this.pathTo.depth);

    for (let index in this.events.path.finish) this.events.path.finish[index]();
  };

  this.updatePath = function (frame) {
    if (!this.path) return;
    const timestamp = performance.now();
    const tick = timestamp - this.pathTick;

    if (tick > this.pathTicks) {
      this.path = false;
      this.setCoordinates(this.pathTo.row, this.pathTo.column, this.pathTo.depth);

      for (let index in this.events.path.finish) this.events.path.finish[index]();

      return;
    }

    this.setCoordinates(this.pathFrom.row + this.pathDifference.row / this.pathTicks * tick, this.pathFrom.column + this.pathDifference.column / this.pathTicks * tick, this.pathFrom.depth + this.pathDifference.depth / this.pathTicks * tick);

    if (frame != this.pathLastFrame) {
      this.pathLastFrame = frame;
      this.pathFrame++;
      if (this.pathFrame == this.pathFrames) this.pathFrame = 0;

      for (let index in this.events.path.frame) this.events.path.frame[index](this.pathFrame);
    }
  };

  this.setPosition = function (position, index = 0) {
    this.setCoordinates(position.row, position.column, position.depth, index);
  };

  this.setCoordinates = function (row, column, depth, index = 0) {
    this.data.position = {
      row,
      column,
      depth
    };
    this.offset = [Math.floor(-(row * 32) + column * 32 - 64), Math.floor(column * 16 + row * 16 - depth * 32)];
    this.index = Math.round(row) * 1000 + Math.round(column) * 1000 + depth * 100 + index;
    if (parent.door != undefined && parent.door.row == Math.round(row) && parent.door.column == Math.round(column)) this.index = -102000 + index;
  };

  this.process = function (timestamp, frame) {
    this.updatePath(frame);
  };

  this.enabled = true;

  this.enable = function () {
    this.enabled = true;
  };

  this.disable = function () {
    this.enabled = false;
  };

  return this;
};// @hash v3-1BBF25C5C24D9890100BE943784ECED2F7CEF1D2
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
Client.rooms.items.sprite = function (parent, image) {
  this.parent = parent;
  this.image = image;
  this.composite = "source-over";

  this.render = function (context, room) {
    context.globalAlpha = this.getAlpha();
    context.globalCompositeOperation = this.composite;
    const offset = this.getOffset();
    context.drawImage(this.image, Math.floor(room[0] + offset[0]), Math.floor(room[1] + offset[1]));
  };

  this.offset = [0, 0];

  this.setOffset = function (left, top) {
    this.offset = [left, top];
  };

  this.getOffset = function () {
    const parentOffset = this.parent.getOffset();
    return [this.offset[0] + parentOffset[0], this.offset[1] + parentOffset[1]];
  };

  this.index = 0;

  this.getIndex = function () {
    return this.parent.index + this.index;
  };

  this.alpha = 1.0;

  this.getAlpha = function () {
    return 1.0 - (1.0 - this.alpha + (1.0 - this.parent.alpha));
  };

  this.mouseover = function (position) {
    return false;
  };

  this.mouseclick = function (event) {};

  this.mousedown = function (event) {};

  this.mousedoubleclick = function (event) {};

  return this;
};// @hash v3-529DCBFD6FEA188F8F00C35CBB09F3B070084ACD
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
Client.rooms.items.cursor = function (parent) {
  const entity = new Client.rooms.items.entity(parent, "cursor");

  entity.render = async function () {
    const cursors = await Assets.getManifest("HabboRoomCursor");
    entity.sprites.length = 0;
    const sprite = new Client.rooms.items.sprite(entity, (await Assets.getSprite("HabboRoomCursor", "HabboRoomCursor_pointer")));
    sprite.setOffset(cursors.visualization["HabboRoomCursor_pointer"].offset.left, cursors.visualization["HabboRoomCursor_pointer"].offset.top);
    entity.sprites.push(sprite);
  };

  return entity;
};// @hash v3-837F295DA7B4B0398A1E529BED09774D066F7534
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
Client.rooms.items.figure = function (parent, figure, direction) {
  const entity = new Client.rooms.items.entity(parent, "figure");

  entity.render = async function () {
    entity.figure = new FigureEntity(figure, {
      direction
    });
    entity.figure.events.render.push(function (sprites) {
      entity.sprites.length = 0;

      for (let index in sprites) {
        let sprite = new Client.rooms.items.sprite(entity, sprites[index].image);

        if (sprites[index].imageData != undefined) {
          sprite.mouseover = function (position) {
            const entityOffset = sprite.parent.getOffset();
            const offset = [Math.floor(position[0] - (entityOffset[0] + sprite.offset[0])), Math.floor(position[1] - (entityOffset[1] + sprite.offset[1]))];
            if (offset[0] < 0 || offset[1] < 0) return false;
            if (offset[0] > sprites[index].image.width || offset[1] > sprites[index].image.height) return false;
            const pixel = (offset[0] + offset[1] * sprites[index].imageData.width) * 4 + 3;
            if (sprites[index].imageData.data[pixel] < 50) return false;
            return true;
          };
        }

        sprite.mouseclick = function (event) {};

        sprite.setOffset(sprites[index].left - 64, sprites[index].top - (128 + 32) + 8);
        sprite.index = sprites[index].index;
        sprite.composite = sprites[index].composite == undefined ? "source-over" : sprites[index].composite;
        entity.sprites.push(sprite);
      }
    });
    entity.figure.process().then(function () {
      entity.figure.render();
    });
  };

  entity.events.path.start.push(async function () {
    if (!entity.data.walk) return;
    await entity.figure.setAction("Move");
    await entity.figure.render();
  });
  entity.events.path.frame.push(async function (frame) {
    /*if(!entity.data.walk)
        return;
      newFrame = Math.floor(frame / 2);
      if(entity.figure.frames["Move"] != newFrame) {
        entity.figure.frames["Move"] = newFrame;
          await entity.figure.render();
    }*/
  });
  entity.events.path.finish.push(async function () {
    if (!entity.data.walk) return;
    await entity.figure.removeAction("Move");
    await entity.figure.render();
  });

  entity.process = function (timestamp, frame) {
    entity.updatePath(frame);
    if (entity.figure.updateActions()) entity.figure.render();
  };

  return entity;
};// @hash v3-CCE0A767918F7791487B26865DB8F5F3FA07218C
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
Client.rooms.items.map = function (parent, map = "", door = {}, floor = {}, wall = {}) {
  const entity = new Client.rooms.items.entity(parent, "map");
  entity.index = -100000;
  entity.map = new Client.rooms.map.entity(map, door, floor, wall);

  entity.render = async function () {
    await entity.map.render();
    entity.parent.center = entity.map.settings.wall.thickness + entity.map.rows * 32;
    const floor = new Client.rooms.items.sprite(entity, entity.map.floorCanvas);
    floor.index = 0;
    floor.setOffset(-entity.parent.center, -(entity.map.depth * 16));

    floor.mouseover = function (position, center) {
      const context = entity.parent.canvas.getContext("2d");
      context.setTransform(1, .5, -1, .5, entity.map.rows * 32 - center, 0);

      for (let path = entity.map.floor.length - 1; path != -1; path--) {
        if (!context.isPointInPath(entity.map.floor[path].path, position[0], position[1])) continue;
        return entity.map.floor[path];
      }

      return false;
    };

    entity.sprites.push(floor);
    const shadowCanvas = document.createElement("canvas");
    shadowCanvas.width = floor.image.width;
    shadowCanvas.height = floor.image.height + 10;
    const shadowContext = shadowCanvas.getContext("2d");

    if (shadowContext.filter != undefined) {
      shadowContext.filter = "blur(10px) brightness(0%) opacity(50%)";
      shadowContext.drawImage(floor.image, 0, 10);
      shadowContext.filter = "blur(0) brightness(100%) opacity(100%)";
      shadowContext.drawImage(floor.image, 0, 0);
      const shadow = new Client.rooms.items.sprite(entity, shadowContext.canvas);
      shadow.index = -1000;
      shadow.setOffset(-entity.parent.center, -(entity.map.depth * 16));

      shadow.mouseover = function (position) {
        return false;
      };

      entity.sprites.push(shadow);
    }

    const wall = new Client.rooms.items.sprite(entity, entity.map.wallCanvas);
    wall.index = -2000;
    wall.setOffset(-entity.parent.center, entity.map.offset);

    wall.mouseover = function (position) {
      return false;
    };

    entity.sprites.push(wall);
  };

  return entity;
};// @hash v3-87E94B3943F3823ACAD04C4C08F6AE106295A98B
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
Client.rooms.items.furniture = function (parent, id, direction) {
  const entity = new Client.rooms.items.entity(parent, "furniture");
  const loading = Assets.getSpritesheet("HabboLoading").then(function (image) {
    const sprite = new Client.rooms.items.sprite(entity, image);
    sprite.setOffset(32, -32);
    entity.sprites.push(sprite);
  });
  entity.furniture = new FurnitureEntity({
    id,
    direction
  });

  entity.render = async function () {
    entity.furniture.events.render.push(function (sprites) {
      entity.sprites.length = 0;

      for (let index in sprites) {
        const layer = sprites[index];
        const sprite = new Client.rooms.items.sprite(entity, layer.sprite);
        sprite.composite = layer.ink;
        sprite.alpha = layer.alpha;
        sprite.tag = layer.tag;

        sprite.mouseover = function (position) {
          if (layer.ignoreMouse == 1) return false;
          const entityOffset = sprite.parent.getOffset();
          const offset = [Math.floor(position[0] - (entityOffset[0] + sprite.offset[0])), Math.floor(position[1] - (entityOffset[1] + sprite.offset[1]))];
          if (offset[0] < 0 || offset[1] < 0) return false;
          if (offset[0] > layer.sprite.width || offset[1] > layer.sprite.height) return false;
          const pixel = (offset[0] + offset[1] * layer.spriteData.width) * 4 + 3;
          if (layer.spriteData.data[pixel] < 50) return false;
          return true;
        };

        sprite.mouseclick = function (event) {
          if (Keys.down["ControlLeft"]) RoomInterface.furniture.pickup.start(entity);else if (Keys.down["AltLeft"]) RoomInterface.furniture.move.start(entity);else if (Keys.down["ShiftLeft"]) RoomInterface.furniture.rotate.start(entity);
        };

        sprite.mousedown = function (event) {
          if (Keys.down["ControlLeft"]) RoomInterface.furniture.pickup.start(entity);
        };

        sprite.mousedoubleclick = function (event) {
          RoomInterface.furniture.use.start(entity, sprite);
        };

        sprite.setOffset(64 - sprites[index].asset.x, 16 - sprites[index].asset.y); //sprite.index = parseInt(sprites[index].index);

        sprite.index = parseInt(sprites[index].z);
        entity.sprites.push(sprite);
      }

      if (entity.video != undefined) entity.sprites.push(entity.video);
    });
    await entity.furniture.process();
    await entity.furniture.render();
  };

  entity.process = function (timestamp, frame) {
    entity.updatePath(frame);
    if (entity.furniture.updateAnimations(timestamp)) entity.furniture.render();
  };

  return entity;
};// @hash v3-20176D0999C41367DA92C1E135AE7C3F60FD8135
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
Client.rooms.items.video = function (parent, link, time) {
  const sprite = new Client.rooms.items.sprite(parent, new Image());
  sprite.image = $('<video muted="muted"></video>')[0];
  sprite.image.addEventListener("loadeddata", function () {
    Assets.getManifest("HabboFurnitureVideos").then(function (data) {
      sprite.visualization = data.visualization[parent.furniture.settings.id];
      if (sprite.visualization == undefined) return;
      sprite.alpha = sprite.visualization.alpha == undefined ? 1.0 : sprite.visualization.alpha;
      sprite.image.currentTime = time;
      const $canvas = $('<canvas width="480" height="360"></canvas>');
      const canvas = $canvas[0].getContext("2d");
      sprite.width = 139;

      sprite.render = function (context, room) {
        if (sprite.image.paused) return;
        const direction = sprite.visualization.directions[parent.furniture.settings.direction];
        if (direction == undefined) return;
        canvas.clearRect(0, 0, canvas.canvas.width, canvas.canvas.height);
        if (parent.furniture.settings.direction == 0 || parent.furniture.settings.direction == 4) canvas.setTransform(1, .5, 0, 1, 0, 0);else if (parent.furniture.settings.direction == 2) canvas.setTransform(1, -.5, 0, 1, 0, sprite.visualization.width / 16 * 9);
        canvas.drawImage(sprite.image, 0, 0, sprite.image.videoWidth, sprite.image.videoHeight, 0, 0, sprite.visualization.width, sprite.visualization.width / 16 * 9);
        context.globalAlpha = sprite.getAlpha();
        context.globalCompositeOperation = sprite.composite;
        const offset = sprite.getOffset();
        context.drawImage($canvas[0], Math.floor(room[0] + offset[0]) + direction.left, Math.floor(room[1] + offset[1]) + direction.top);
      };

      sprite.image.play();
    });
  });
  sprite.image.src = link;
  return sprite;
};// @hash v3-01B80FE6C3EC670AF4782D65DD4DB6FF85142BD3
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
var _temp;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const RoomInterface = new (_temp = class {
  constructor() {
    _defineProperty(this, "users", {});

    _defineProperty(this, "furnitures", {});

    _defineProperty(this, "active", false);

    _defineProperty(this, "events", {
      start: [],
      stop: []
    });

    this.element = document.createElement("div");
    this.element.className = "room";
    Client.element.prepend(this.element);
    this.entity = new RoomEntity(this.element);
  }

  start() {
    if (this.active == true) return;
    this.active = true;

    for (let index in this.events.start) this.events.start[index]();

    this.entity.canvas.enabled = true;
  }

  async stop() {
    RoomInterface.active = false;
    this.entity.canvas.enabled = false;

    for (let index in RoomInterface.events.stop) RoomInterface.events.stop[index]();

    return new Promise(function (resolve) {
      window.requestAnimationFrame(function () {
        window.requestAnimationFrame(function () {
          resolve();
        });
      });
    });
  }

  render() {
    if (!RoomInterface.active) return;
    window.requestAnimationFrame(RoomInterface.render);

    if (RoomInterface.frameLimit != 0) {
      let timestamp = performance.now();
      const delta = timestamp - RoomInterface.frameLimitStamp;
      const interval = 1000 / RoomInterface.frameLimit;

      if (delta > interval) {
        RoomInterface.frameLimitStamp = timestamp - delta % interval;
        timestamp = performance.now();
        const {
          median,
          milliseconds,
          frames
        } = RoomInterface.entity.render();

        if (timestamp - RoomInterface.frameAdjustTimestamp > 1000) {
          RoomInterface.frameAdjustTimestamp = timestamp;
          RoomInterface.frameAdjustCounts.push(frames);

          if (RoomInterface.frameAdjustCounts.length == 5) {
            RoomInterface.frameAdjustCounts.splice(0, 1); //console.log("median of frames per seconds in 5 seconds is " + Client.utils.getArrayMedian(RoomInterface.frameAdjustCounts));
          } //console.log("we have rendered " + frames + " frames and we wanted " + RoomInterface.frameLimit + ", render took " + Math.round(performance.now() - timestamp) + "ms, we can afford " + Math.floor(1000 / (performance.now() - timestamp)) + " frames");

        }
        /*if((RoomInterface.frameLimit - frames) > 3) {
            console.warn("[RoomInterface]%c We're detecting an urge for more frames (" + frames + "/" + RoomInterface.frameLimit + ") than we can deliver, render took " + median + "/" + interval + "!", "color: lightblue");
              if(RoomInterface.frameLimit > 12) {
                RoomInterface.frameLimit -= 2;
                  if(RoomInterface.frameLimit < 12)
                    RoomInterface.frameLimit = 12;
                  console.warn("[RoomInterface]%c Lowered expected frame count down to " + RoomInterface.frameLimit + "!", "color: lightblue");
            }
            
        }*/

      }
    } else RoomInterface.entity.render();
  }

  async clear() {
    this.chat.clear();
    this.entity.entities.length = 0;
    if (this.active) await this.stop();
  }

}, _temp)();// @hash v3-65254E72736405464CD8F6642A7F8268B87BCE4B
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
RoomInterface.chat = new function () {
  this.element = document.createElement("div");
  this.element.className = "room-interface-chat";
  RoomInterface.element.append(this.element);
  this.interval = null;
  this.messages = [];

  this.startInterval = function () {
    if (this.interval != null) return;
    this.stopInterval();
    this.interval = setInterval(function () {
      RoomInterface.chat.updateMessages();
    }, 3 * 1000);
  };

  this.stopInterval = function () {
    if (this.interval != null) clearInterval(this.interval);
    this.interval = null;
  };

  this.clear = function () {
    for (let index in this.messages) this.messages[index].remove();

    this.messages.length = 0;
  };

  this.addMessage = async function (style, message, center = 0, color = undefined) {
    let sprite = await Assets.getSprite("HabboRoomChat", "HabboRoomChat_" + style);
    if (color != undefined) sprite = await Assets.getSpriteColor("HabboRoomChat", "HabboRoomChat_" + style, color);
    const canvas = document.createElement("canvas");
    canvas.className = "room-interface-chat-message";
    const context = canvas.getContext("2d");
    const visualization = JSON.parse(JSON.stringify(this.assets.visualization["default"]));

    if (this.assets.visualization["HabboRoomChat_" + style] != undefined) {
      for (let key in this.assets.visualization["HabboRoomChat_" + style]) {
        visualization[key] = this.assets.visualization["HabboRoomChat_" + style][key];
      }
    }

    const parts = Client.utils.getStringMarkup(message);
    let messageWidth = 0;

    for (let index in parts) {
      context.font = "13px " + visualization.font + " " + parts[index].type;
      parts[index].width = context.measureText(parts[index].message).width;
      messageWidth += parts[index].width;
    }

    context.canvas.width = visualization.left + messageWidth + visualization.width;
    context.canvas.height = sprite.height;
    context.font = "13px " + visualization.font;
    context.drawImage(sprite, 0, 0, visualization.left, context.canvas.height, 0, 0, visualization.left, context.canvas.height);
    context.drawImage(sprite, visualization.left, visualization.top, visualization.width, context.canvas.height, visualization.left, visualization.top, messageWidth, context.canvas.height);
    context.drawImage(sprite, visualization.left + visualization.width, 0, sprite.width - (visualization.left + visualization.width), context.canvas.height, visualization.left + messageWidth, 0, sprite.width - (visualization.left + visualization.width), context.canvas.height);
    let left = 0;
    context.fillStyle = visualization.color;

    for (let index in parts) {
      context.font = "13px " + visualization.font + " " + parts[index].type;
      context.fillText(parts[index].message, visualization.left + left, context.canvas.height - visualization.offset);
      left += parts[index].width;
    }

    canvas.style.left = `${center - context.canvas.width / 2}px`;
    this.messages.push(canvas); //this.history.addMessage(context.canvas, center - (context.canvas.width / 2));

    this.element.append(canvas);
    this.updateMessages();
    this.startInterval();
  };

  this.updateMessages = function () {
    for (let index = 0; index < this.messages.length; index++) {
      const top = this.messages[index].offsetTop;

      if (top < 30) {
        this.messages[index].remove();
        this.messages.splice(index, 1);
        continue;
      }

      this.messages[index].style.top = `${top - 30}px`;
    }

    if (this.messages.length == 0) this.stopInterval();
  };

  this.render = function () {
    if (this.messages.length == 0) return;
    if (this.margin == RoomInterface.entity.offset[0]) return;
    this.margin = RoomInterface.entity.offset[0];
    this.element.style.marginLeft = `${RoomInterface.entity.offset[0]}px`;
  };

  RoomInterface.entity.events.render.push(function () {
    RoomInterface.chat.render();
  });
}();
Loader.addAsset(async function () {
  RoomInterface.chat.assets = await Assets.getManifest("HabboRoomChat");
});// @hash v3-6EF4D369BD8673C62B263E9807BB0D80E00DCA8D
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
SocketMessages.register("OnRoomUserChat", async function (data) {
  const user = RoomInterface.users[data.id];
  const center = RoomInterface.entity.center;
  const position = RoomInterface.entity.offset;
  const offset = user.getOffset();
  RoomInterface.chat.addMessage("bot_a", "**" + user.data.name + ":** " + data.message, center + offset[0] + 64);
  await user.figure.setAction("Talk");
  setTimeout(async function () {
    await user.figure.removeAction("Talk");
    user.figure.render();
  }, data.message.length * 100);
});// @hash v3-A0B4F95A9AA277DB2F3487DFC37AE71B877C6DF3
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
RoomInterface.cursor = new function () {
  this.down = false;
  this.downTimestamp = 0;
  this.downFrame = 0;
  this.position = null;
  this.events = {
    hover: [],
    unhover: [],
    click: [],
    doubleclick: []
  };
  RoomInterface.entity.canvas.canvas.addEventListener("mousedown", event => {
    RoomInterface.cursor.down = true;
    RoomInterface.cursor.downTimestamp = performance.now();
    RoomInterface.cursor.position = [event.offsetX, event.offsetY];

    if (RoomInterface.frameLimit != 0) {
      RoomInterface.cursor.downFrame = RoomInterface.frameLimit;
      RoomInterface.frameLimit = 0;
    }
  });
  RoomInterface.entity.canvas.canvas.addEventListener("mouseup", () => {
    RoomInterface.cursor.down = false;
    RoomInterface.frameLimit = RoomInterface.cursor.downFrame;
  });
  RoomInterface.entity.canvas.canvas.addEventListener("mousemove", event => {
    if (RoomInterface.entity.currentEntity != undefined && RoomInterface.cursor.down) RoomInterface.entity.currentEntity.sprite.mousedown(event);

    if (!RoomInterface.cursor.down || Keys.down["ControlLeft"] || Keys.down["ShiftLeft"] || Keys.down["AltLeft"]) {
      RoomInterface.cursor.position = [event.offsetX, event.offsetY];
      return;
    } //RoomInterface.entity.offset[0] += (event.offsetX - RoomInterface.cursor.position[0]);
    //RoomInterface.entity.offset[1] += (event.offsetY - RoomInterface.cursor.position[1]);


    RoomInterface.cursor.position = [event.offsetX, event.offsetY];
  });
  RoomInterface.entity.canvas.canvas.addEventListener("touchstart", event => {
    RoomInterface.cursor.position = [event.touches[0].clientX, event.touches[0].clientY];
    RoomInterface.cursor.down = true;
  });
  RoomInterface.entity.canvas.canvas.addEventListener("touchmove", event => {
    if (RoomInterface.cursor.position == null) RoomInterface.cursor.position = [event.touches[0].clientX, event.touches[0].clientY];
    if (!RoomInterface.cursor.down) return;
    RoomInterface.entity.offset.left += event.touches[0].clientX - RoomInterface.cursor.position[0];
    RoomInterface.entity.offset.top += event.touches[0].clientY - RoomInterface.cursor.position[1];
    RoomInterface.cursor.position = [event.touches[0].clientX, event.touches[0].clientY];
  });
  RoomInterface.entity.canvas.canvas.addEventListener("touchend", event => {
    RoomInterface.cursor.down = false;
  });
  RoomInterface.entity.canvas.canvas.addEventListener("dblclick", event => {
    if (RoomInterface.furniture.place.enabled) return;
    if (RoomInterface.entity.currentEntity != undefined) RoomInterface.entity.currentEntity.sprite.mousedoubleclick(event);

    for (let index in RoomInterface.cursor.events.doubleclick) RoomInterface.cursor.events.doubleclick[index](RoomInterface.entity.currentEntity, event);
  });
  RoomInterface.entity.canvas.canvas.addEventListener("click", event => {
    if (performance.now() - RoomInterface.cursor.downTimestamp > 250) return;

    if (RoomInterface.furniture.place.enabled) {
      RoomInterface.furniture.place.click();
      return;
    }

    if (RoomInterface.entity.currentMapEntity != undefined) {
      if (!(Keys.down["ControlLeft"] || Keys.down["ShiftLeft"] || Keys.down["AltLeft"])) SocketMessages.send({
        OnRoomMapClick: {
          row: RoomInterface.entity.currentMapEntity.result.row,
          column: RoomInterface.entity.currentMapEntity.result.column
        }
      });
    }

    if (RoomInterface.entity.currentEntity != undefined) RoomInterface.entity.currentEntity.sprite.mouseclick(event);

    for (let index in RoomInterface.cursor.events.click) RoomInterface.cursor.events.click[index](RoomInterface.entity.currentEntity, event);
  });
  RoomInterface.entity.canvas.canvas.addEventListener("mouseout", () => {
    RoomInterface.cursor.down = false;
    RoomInterface.cursor.position = [0, 0];
  });
  const cursor = new Client.rooms.items.furniture(RoomInterface.entity, "HabboRoomCursor", 0);
  cursor.name = "cursor";
  cursor.render();
  cursor.disable();
  RoomInterface.events.start.push(function () {
    RoomInterface.entity.addEntity(cursor);
  });
  RoomInterface.entity.events.render.push(function () {
    RoomInterface.entity.currentMapEntity = RoomInterface.entity.getEntity(RoomInterface.cursor.position, "map");

    if (RoomInterface.entity.currentMapEntity == undefined) {
      if (cursor.enabled) {
        cursor.disable();

        for (let index in RoomInterface.cursor.events.unhover) RoomInterface.cursor.events.unhover[index]();
      }
    } else {
      const row = parseInt(RoomInterface.entity.currentMapEntity.result.row),
            column = parseInt(RoomInterface.entity.currentMapEntity.result.column),
            depth = Math.round(RoomInterface.entity.currentMapEntity.result.depth);
      cursor.setCoordinates(row, column, depth, -2000);
      cursor.enable();

      for (let index in RoomInterface.cursor.events.hover) RoomInterface.cursor.events.hover[index]({
        row,
        column,
        depth
      });
    }

    RoomInterface.entity.currentEntity = RoomInterface.entity.getEntity(RoomInterface.cursor.position);
  });
}();// @hash v3-AC4D58271A02932A56D381CE8AEAE82EB0C209C9
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
RoomInterface.display = new function () {
  this.element = document.createElement("div");
  this.element.className = "room-interface-display";
  this.element.innerHTML = `
        <div class="room-interface-display-content"></div>

        <div class="room-interface-display-buttons"></div> 
    `;
  this.element.style.display = "none";
  RoomInterface.element.append(this.element);
  this.content = this.element.querySelector(".room-interface-display-content");
  this.buttons = this.element.querySelector(".room-interface-display-buttons");

  this.addButton = function (text, click) {
    const element = document.createElement("div");
    element.className = "room-interface-display-button";
    element.innerHTML = text;
    this.buttons.append(element);
    +element.click(click);
  };

  this.figure = async function (entity) {
    this.entity = entity;
    this.element.style.display = "none";
    this.content.innerHTML = `
            <div class="room-interface-display-title">${entity.data.name}</div>

            <div class="room-interface-display-break"></div>

            <div class="room-interface-display-grid">
                <div class="room-interface-display-figure room-interface-display-bot">
                    <canvas width="256" height="256"></canvas>
                </div>

                <div class="room-interface-display-badges"></div>
            </div>
        `;
    this.buttons.innerHTML = "";
    const grid = this.content.querySelector(".room-interface-display-grid");
    const figure = grid.querySelector(".room-interface-display-figure");
    const canvas = figure.querySelector("canvas");
    new FigureRenderer(entity.data.figure, {
      direction: 4
    }, canvas);
    const badges = grid.querySelector(".room-interface-display-badges");
    const badge = [];
    badge[0] = document.createElement("div");
    badge[0].className = "room-interface-display-badge";
    badges.append(badge[0]);
    const group = document.createElement("div");
    group.className = "room-interface-display-group";
    badges.append(group);

    for (let index = 1; index < 5; index++) {
      badge[index] = document.createElement("div");
      badge[index].className = "room-interface-display-badge";
      badges.append(badge[index]);
    }

    SocketMessages.sendCall({
      OnUserBadgeRequest: entity.data.id
    }, "OnUserBadgeRequest").then(function (badges) {
      for (let index in badges) badge[index].append(new BadgeRenderer(badges[index].badge));
    });
    this.element.style.display = "block";
  };

  this.furniture = async function (entity) {
    this.entity = entity;
    this.element.style.display = "none";
    const furniture = await Furnitures.get(entity.furniture.settings.id);
    this.content.innerHTML = `
            <div class="room-interface-display-title">${furniture.title}</div>

            <div class="room-interface-display-break"></div>

            <canvas class="room-interface-display-canvas"></canvas>
        `;
    this.buttons.innerHTML = "";

    if (furniture.description.length != 0) {
      this.content.innerHTML += `
                <div class="room-interface-display-break"></div>

                <div class="room-interface-display-description">${furniture.description}</div>
            `;
    }

    const canvas = this.content.querySelector(".room-interface-display-canvas");
    new FurnitureRenderer({
      id: furniture.id,
      direction: 4
    }, canvas, "rgb(28, 28, 26)");

    if (RoomInterface.data.rights.includes(Client.user.id) || entity.data.user == Client.user.id) {
      this.addButton("Pickup", function () {
        RoomInterface.furniture.pickup.start(entity);
      });
    }

    if (RoomInterface.data.rights.includes(Client.user.id)) {
      this.addButton("Rotate", function () {
        RoomInterface.furniture.rotate.start(entity);
      });
      this.addButton("Move", function () {
        RoomInterface.furniture.move.start(entity);
      });

      if (RoomInterface.furniture.logics[entity.furniture.types.logic] != undefined) {
        this.addButton("Use", function () {
          RoomInterface.furniture.use.start(entity);
        });
      }
    }

    this.element.style.display = "block";
  };

  this.hide = function () {
    RoomInterface.display.entity = undefined;
    RoomInterface.display.element.style.display = "none";
  };

  RoomInterface.cursor.events.click.push(function (entity) {
    if (entity == undefined) {
      RoomInterface.display.hide();
      return;
    }

    switch (entity.entity.name) {
      case "furniture":
        RoomInterface.display.furniture(entity.entity);
        break;

      case "figure":
        RoomInterface.display.figure(entity.entity);
        break;
    }
  });
}();// @hash v3-CAFBAD21CD8E7C351E1F1132D4C71287A4BEDEF3
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
RoomInterface.display.users = new function () {
  this.tabs = new function () {
    this.entity = undefined;
    this.element = document.createElement("div");
    this.element.className = "room-interface-user";
    RoomInterface.element.append(this.element);

    this.click = function (entity) {
      this.element.innerHTML = `
                <div class="room-interface-user-header">${entity.entity.data.name}</div>
                <div class="room-interface-user-content"></div>
                <div class="room-interface-user-footer"></div>
                
                <div class="room-interface-user-arrow"></div>
            `;

      if (Client.theme.get("rooms/interface/tabs/figure", false) == true) {
        this.canvas = document.createElement("canvas");
        this.canvas.width = 256;
        this.canvas.height = 256;
        this.canvas.className = "room-interface-user-figure";
        this.element.append(this.canvas);
        entity.entity.figure.events.render.push(this.render);
      }

      this.content = this.element.querySelector(".room-interface-user-content");
      this.entity = entity;
      this.show("default");
    };

    this.render = function (sprites) {
      const entity = RoomInterface.display.users.tabs;
      const context = entity.canvas.getContext("2d");
      context.clearRect(0, 0, context.canvas.width, context.canvas.height);

      for (let index in sprites) context.drawImage(sprites[index].image, sprites[index].left, sprites[index].top);
    };

    this.show = async function (page, previous = "default") {
      this.content.innerHTML = "";

      switch (page) {
        case "default":
          {
            if (Client.user.id == this.entity.entity.data.id) {
              this.add("Actions", function () {
                RoomInterface.display.users.tabs.show("actions", "default");
              });
            } else {
              this.add("Manage", function () {
                RoomInterface.display.users.tabs.show("manage", "default");
              });
            }

            if (RoomInterface.data.rights.includes(Client.user.id) && Client.user.id != this.entity.entity.data.id) {
              this.add("Moderate", function () {
                RoomInterface.display.users.tabs.show("moderate", "default");
              });
            }

            break;
          }

        case "manage":
          {
            const friend = Client.user.friends[this.entity.entity.data.id];

            if (friend != undefined) {
              if (friend.status == -1) {
                this.add("Cancel Friend Invite", async function () {
                  await SocketMessages.sendCall({
                    OnUserFriendRemove: {
                      user: RoomInterface.display.users.tabs.entity.entity.data.id
                    }
                  }, "OnUserFriendRemove");
                  RoomInterface.display.users.tabs.hide();
                });
              } else if (friend.status == 0) {
                this.add("Accept Friend Invite", async function () {
                  await SocketMessages.sendCall({
                    OnUserFriendAdd: {
                      user: RoomInterface.display.users.tabs.entity.entity.data.id
                    }
                  }, "OnUserFriendAdd");
                  RoomInterface.display.users.tabs.hide();
                });
              } else {
                this.add("Remove Friend Invite", async function () {
                  await SocketMessages.sendCall({
                    OnUserFriendRemove: {
                      user: RoomInterface.display.users.tabs.entity.entity.data.id
                    }
                  }, "OnUserFriendRemove");
                  RoomInterface.display.users.tabs.hide();
                });
              }
            } else {
              this.add("Send Friend Invite", async function () {
                await SocketMessages.sendCall({
                  OnUserFriendAdd: {
                    user: RoomInterface.display.users.tabs.entity.entity.data.id
                  }
                }, "OnUserFriendAdd");
                RoomInterface.display.users.tabs.hide();
              });
            }

            break;
          }

        case "actions":
          {
            this.add("Wave", function () {
              SocketMessages.sendCall({
                OnRoomUserAction: "Wave"
              }, "OnRoomUserAction");
              RoomInterface.display.users.tabs.hide();
            });
            this.add("Blow", function () {
              SocketMessages.sendCall({
                OnRoomUserAction: "Blow"
              }, "OnRoomUserAction");
              RoomInterface.display.users.tabs.hide();
            });
            this.add("Laugh", function () {
              SocketMessages.sendCall({
                OnRoomUserAction: "Laugh"
              }, "OnRoomUserAction");
              RoomInterface.display.users.tabs.hide();
            });
            this.add("Idle", function () {
              SocketMessages.sendCall({
                OnRoomUserAction: "Idle"
              }, "OnRoomUserAction");
              RoomInterface.display.users.tabs.hide();
            });
            break;
          }

        case "moderate":
          {
            if (Client.user.id == RoomInterface.data.user) {
              RoomInterface.data.rights = await SocketMessages.sendCall({
                OnRoomRightsUpdate: null
              }, "OnRoomRightsUpdate");
              this.add((RoomInterface.data.rights.includes(this.entity.entity.data.id) ? "Revoke" : "Grant") + " Rights", async function () {
                await SocketMessages.sendCall({
                  OnRoomRightsUpdate: {
                    user: RoomInterface.display.users.tabs.entity.entity.data.id
                  }
                }, "OnRoomRightsUpdate");
                RoomInterface.display.users.tabs.show("moderate", "default");
              });
            }

            break;
          }
      }

      if (page != previous) {
        this.add("Back", function () {
          RoomInterface.display.users.tabs.show(previous, "default");
        });
      }
    };

    this.add = function (text, click) {
      const element = document.createElement("div");
      element.className = "room-interface-user-item";
      element.innerHTML = text;
      element.addEventListener("click", () => {
        click();
      });
      this.content.append(element);
    };

    this.hide = function () {
      if (this.canvas != undefined) {
        const index = this.entity.entity.figure.events.render.indexOf(this.render);
        this.entity.entity.figure.events.render.splice(index, 1);
        this.canvas.remove();
        delete this.canvas;
      }

      this.entity = undefined;
      this.element.style.display = "none";
    };

    this.hover = function () {
      if (this.entity == undefined) return;
      const center = RoomInterface.entity.center;
      const position = RoomInterface.entity.offset;
      const offset = this.entity.entity.getOffset();
      this.element.style.left = `${center + position[0] + offset[0]}px`;
      this.element.style.bottom = `${RoomInterface.$element.height() - (position[1] + offset[1])}px`;
      this.element.style.display = "block";
    };

    RoomInterface.cursor.events.click.push(function (entity) {
      if (entity == undefined || entity.entity.name != "figure") {
        RoomInterface.display.users.tabs.hide();
        return;
      }

      RoomInterface.display.users.tabs.hide();
      RoomInterface.display.users.tabs.click(entity);
    });
    RoomInterface.entity.events.render.push(function () {
      RoomInterface.display.users.tabs.hover();
    });
  }();

  this.request = function (entity) {
    const element = document.createElement("div");
    element.className = "room-interface-user room-interface-user-request";
    element.innerHTML = `
            <div class="user-profile" data-user="${entity.data.id}"><i class="sprite-user-profile"></i> <b>Friend request from ${entity.data.name}</b></div>

            <div class="room-interface-user-request-close"></div>

            <div class="room-interface-user-request-buttons">
                <div class="room-interface-user-request-decline dialog-button">Decline</div>
                <div class="room-interface-user-request-accept dialog-button"><i class="sprite-success"></i> Accept</div>
            </div>

            <div class="room-interface-user-arrow"></div>
        `;
    RoomInterface.element.append(element);
    element.querySelector(".room-interface-user-request-close").addEventListener("click", () => {
      destroy();
    });
    element.querySelector(".room-interface-user-request-decline").addEventListener("click", async () => {
      await SocketMessages.sendCall({
        OnUserFriendRemove: {
          user: entity.data.id
        }
      }, "OnUserFriendRemove");
      destroy();
    });
    element.querySelector(".room-interface-user-request-accept").addEventListener("click", async () => {
      await SocketMessages.sendCall({
        OnUserFriendAdd: {
          user: entity.data.id
        }
      }, "OnUserFriendUpdate");
      destroy();
    });

    function destroy() {
      const index = RoomInterface.entity.events.render.indexOf(hover);
      RoomInterface.entity.events.render.splice(index, 1);
      element.remove();
    }

    ;
    this.destroy = destroy;

    function hover() {
      const center = RoomInterface.entity.center;
      const position = RoomInterface.entity.offset;
      const offset = entity.getOffset();
      element.style.left = `${center + position[0] + offset[0]}px`;
      element.style.bottom = `${RoomInterface.$element.height() - (position[1] + offset[1])}px`;
      element.style.display = "block";
    }

    ;
    RoomInterface.entity.events.render.push(hover);
  };

  this.name = document.createElement("div");
  this.name.className = "room-interface-user";
  RoomInterface.element.append(this.name);

  this.hover = function (entity) {
    if (entity == undefined || entity.entity.name != "figure") {
      this.name.style.display = "none";
      return;
    }

    if (RoomInterface.display.users.tabs.entity != undefined && entity.entity == RoomInterface.display.users.tabs.entity.entity) {
      this.name.style.dispaly = "none";
      return;
    }

    this.name.innerHTML = `
            <div class="room-interface-user-title">${entity.entity.data.name}</div>
            
            <div class="room-interface-user-arrow"></div>
        `;
    const center = RoomInterface.entity.center;
    const position = RoomInterface.entity.offset;
    const offset = entity.entity.getOffset();
    this.name.style.left = `${center + position[0] + offset[0]}px`;
    this.name.style.bottom = `${RoomInterface.$element.height() - (position[1] + offset[1])}px`;
    this.name.style.display = "block";
  };

  RoomInterface.entity.events.render.push(function () {
    const entity = RoomInterface.entity.currentEntity;
    RoomInterface.display.users.hover(entity);
  });
  RoomInterface.events.stop.push(function () {
    RoomInterface.display.users.tabs.hide();

    for (let id in RoomInterface.users) if (RoomInterface.users[id].request != undefined) RoomInterface.users[id].request.destroy();
  });
}();// @hash v3-84E69751C307233D1ECC2616C02F16F68C6401A8
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
const RoomInterfaceMenu = new class {
  constructor() {
    this.element = document.createElement("div");
    this.element.className = "room-interface-menu active";
    this.element.innerHTML = `
            <div class="room-interface-menu-toggle"></div>

            <div class="room-interface-menu-content"></div>
        `;
    RoomInterface.element.append(this.element);
    this.toggle = this.element.querySelector(".room-interface-menu-toggle");
    this.toggle.addEventListener("click", () => {
      this.element.classList.toggle("active");
    });
    this.content = this.element.querySelector(".room-interface-menu-content");
    this.link("information", "Information", function () {
      RoomInterfaceInformation.toggle();
    });
    const settings = this.link("settings", "Settings", function () {
      Client.rooms.settings.toggle();
    });
    RoomInterface.events.start.push(function () {
      if (RoomInterface.data.user == Client.user.id) settings.style.display = "block";else settings.style.display = "none";
    });
  }

  link(identifier, title, click) {
    const element = document.createElement("div");
    element.className = `room-interface-menu-link room-interface-menu-${identifier}`;
    element.innerHTML = title;
    this.content.append(element);
    element.addEventListener("click", () => {
      click();
    });
    return element;
  }

}();// @hash v3-1EC59F803C6E55133B353B0C425BFBE7DD16CC2E
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
const RoomInterfaceInformation = new class extends Dialog {
  constructor(settings = {}) {
    settings = {
      title: "Room Information",
      size: {
        width: 240
      },
      offset: {
        type: "center",
        top: -120
      }
    };
    super(settings);
    this.events.create.push(() => {
      this.content.classList.add("room-interface-information");
      this.title = document.createElement("p");
      this.title.className = "room-interface-information-title";
      this.content.append(this.title);
      this.owner = document.createElement("p");
      this.owner.className = "room-interface-information-owner";
      this.content.append(this.owner);
      this.description = document.createElement("p");
      this.description.className = "room-interface-information-description";
      this.content.append(this.description);
      this.thumbnail = document.createElement("div");
      this.thumbnail.className = "room-interface-information-thumbnail";
      this.content.append(this.thumbnail);
    });
    this.events.show.push(() => {
      this.title.innerText = RoomInterface.data.title;
      this.owner.innerText = "";
      this.description.innerText = RoomInterface.data.description == undefined ? "" : RoomInterface.data.description;
      Game.getUser(RoomInterface.data.user).then(user => {
        this.owner.innerText = "By " + user.name;
      });
    });
    RoomInterface.events.stop.push(() => {
      if (this.active) this.hide();
    });
  }

}();// @hash v3-D5CD2B9CA5EFA51574EE34ADE9506F9012564BBE
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
SocketMessages.register("OnRoomEnter", async function (data) {
  RoomInterface.entity.door = undefined;
  if (data.map.floor[data.map.door.row + 1] == undefined || data.map.floor[data.map.door.row + 1][data.map.door.column] == 'X') RoomInterface.entity.door = data.map.door;
  Client.rooms.navigator.hide();
  await RoomInterface.clear();
  RoomInterface.data = data;
  SocketMessages.sendCall({
    OnRoomMapStackUpdate: null
  }, "OnRoomMapStackUpdate").then(function (result) {
    RoomInterface.data.map.stack = result;
  });
  RoomInterface.map = new Client.rooms.items.map(RoomInterface.entity, data.map.floor, data.map.door, {
    thickness: data.floor_thickness,
    material: data.floor_material
  }, {
    thickness: data.wall_thickness,
    material: data.wall_material
  });
  RoomInterface.map.render().then(function () {
    RoomInterface.entity.addEntity(RoomInterface.map);
    const width = RoomInterface.element.clientWidth,
          height = RoomInterface.element.clientHeight;
    RoomInterface.entity.offset = [width / 2 - (RoomInterface.map.map.rows * 16 + RoomInterface.map.map.columns * 16), height / 2 - (RoomInterface.map.map.rows * 8 + RoomInterface.map.map.columns * 8)];
  });
  RoomInterface.start();
});// @hash v3-8AA55E7D205B52C7AAAE47182B9FCA0FD17FA44D
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
SocketMessages.register("OnRoomEntityAdd", async function (data) {
  if (data.furnitures != undefined) {
    if (data.furnitures.length == undefined) data.furnitures = [data.furnitures];

    for (let index in data.furnitures) {
      const dataFurniture = data.furnitures[index];
      let entity = new Client.rooms.items.furniture(RoomInterface.entity, dataFurniture.furniture, dataFurniture.position.direction);
      entity.setPosition(dataFurniture.position);
      if (dataFurniture.animation) entity.furniture.update({
        animation: dataFurniture.animation
      });
      entity.render();
      entity.data = data.furnitures[index];
      RoomInterface.entity.addEntity(entity);
      RoomInterface.furnitures[dataFurniture.id] = entity;
    }
  }

  if (data.users != undefined) {
    if (data.users.length == undefined) data.users = [data.users];

    for (let index in data.users) {
      let entity = new Client.rooms.items.figure(RoomInterface.entity, data.users[index].figure, data.users[index].position.direction);
      entity.setPosition(data.users[index].position);
      entity.render();

      if (data.users[index].actions != undefined) {
        await entity.figure.setActions(data.users[index].actions);
        entity.figure.render();
      }

      entity.data = data.users[index];
      RoomInterface.entity.addEntity(entity);
      RoomInterface.users[data.users[index].id] = entity;
      const friend = Client.user.friends[data.users[index].id];

      if (friend != undefined) {
        if (friend.status == 0 && friend.request == undefined) friend.request = new RoomInterface.display.users.request(RoomInterface.users[data.users[index].id]);
      }
    }
  }
});// @hash v3-0573C685CACAD818356EEA0D4138248837730CC6
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
SocketMessages.register("OnRoomEntityUpdate", async function (data) {
  for (let key in data) {
    for (let index in data[key]) {
      const item = data[key][index];
      const entity = RoomInterface[key][index];

      if (item.position != undefined) {
        if (item.position.row != undefined && item.position.column != undefined && item.position.depth != undefined) {
          entity.stopPath(true);

          if (item.position.speed != 0) {
            if (key == "users") entity.data.walk = item.position.walk == undefined ? false : item.position.walk;
            entity.setPath(entity.data.position, item.position, item.position.speed);
          } else entity.setCoordinates(item.position.row, item.position.column, item.position.depth);
        }
      }

      for (let property in item) RoomInterface[key][index].data[property] = item[property];
    }
  }

  if (data.users != undefined) {
    for (let index in data.users) {
      let render = false;

      if (data.users[index].position != undefined) {
        if (data.users[index].position.direction != undefined) {
          RoomInterface.users[index].figure.direction = data.users[index].position.direction;
          render = true;
        }

        if (data.users[index].position.actions != undefined) {
          await RoomInterface.users[index].figure.setActions(data.users[index].position.actions);
          render = true;
        }
      }

      if (data.users[index].action != undefined) {
        await RoomInterface.users[index].figure.setAction(data.users[index].action.action);
        setTimeout(async function () {
          await RoomInterface.users[index].figure.removeAction(data.users[index].action.action);
          RoomInterface.users[index].figure.render();
        }, data.users[index].action.time);
      }

      RoomInterface.users[index].figure.render();
    }
  }

  if (data.furnitures != undefined) {
    for (let index in data.furnitures) {
      if (data.furnitures[index].animation != undefined) {
        RoomInterface.furnitures[index].furniture.setAnimation(data.furnitures[index].animation);
      }

      if (data.furnitures[index].position != undefined) {
        if (data.furnitures[index].position.direction != undefined) {
          RoomInterface.furnitures[index].furniture.setDirection(data.furnitures[index].position.direction);
        }
      }

      RoomInterface.furnitures[index].furniture.render();
    }
  }
});// @hash v3-DC880F6791E1DA5A442878A29474D88D4BED345D
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
SocketMessages.register("OnRoomEntityRemove", async function (data) {
  if (data.furnitures != undefined) {
    if (data.furnitures.length == undefined) data.furnitures = [data.furnitures];

    for (let index in data.furnitures) {
      const id = data.furnitures[index];
      const entity = RoomInterface.furnitures[id];
      if (RoomInterface.display.entity == entity) RoomInterface.display.hide();
      RoomInterface.entity.removeEntity(entity);
      delete RoomInterface.furnitures[id];
    }
  }

  if (data.users != undefined) {
    if (data.users.length == undefined) data.users = [data.users];

    for (let index in data.users) {
      const id = data.users[index];
      const entity = RoomInterface.users[id];
      if (RoomInterface.display.entity == entity) RoomInterface.display.hide();
      RoomInterface.entity.removeEntity(entity);
      delete RoomInterface.users[id];
    }
  }
});// @hash v3-0A7B61B4E48DF3D4A7EA372A6C1DA4E23C2F4F9B
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
SocketMessages.register("OnRoomFurnitureVideoStart", function (data) {
  const entity = RoomInterface.furnitures[data.id];
  if (entity == undefined) return;

  if (entity.video != undefined) {
    entity.video.image.pause();
    entity.video.image.remove();
    delete entity.video;
  }

  entity.video = new Client.rooms.items.video(entity, Loader.settings.api.youtube + data.video + ".mp4", data.time == undefined ? 0 : data.time);
  entity.sprites.push(entity.video);
});
SocketMessages.register("OnRoomFurnitureVideoStop", function (data) {
  const entity = RoomInterface.furnitures[data];
  if (entity == undefined) return;
  if (entity.video == undefined) return;
  entity.video.image.pause();
  entity.video.image.remove();
  delete entity.video;
});// @hash v3-ACD6491FA2D83A6BD45F566B3264539A45CA4F90
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
SocketMessages.register("OnRoomFurnitureFlash", function (data) {
  const furnitures = [];

  for (let id in RoomInterface.furnitures) {
    const entity = RoomInterface.furnitures[id];
    if (entity.data.furniture != data.id) continue;
    furnitures.push(id);
  }

  function setAnimation(animation) {
    for (let index in furnitures) RoomInterface.furnitures[furnitures[index]].furniture.setAnimation(animation);
  }

  ; // TODO: wtf?

  setAnimation(data.animation);
  setTimeout(function () {
    setAnimation(0);
    setTimeout(function () {
      setAnimation(data.animation);
      setTimeout(function () {
        setAnimation(0);
        setTimeout(function () {
          setAnimation(data.animation);
          setTimeout(function () {
            setAnimation(0);
          }, 500);
        }, 500);
      }, 500);
    }, 500);
  }, 500);
});// @hash v3-BEACE474A8B80F1E9EF5D3294D5C2292D4EBCE77
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
SocketMessages.register("OnRoomUserEffect", function (data) {
  if (data.length == undefined) data = [data];

  for (let index in data) {
    const user = RoomInterface.users[data[index].id];
    if (user == undefined) continue;
    user.figure.setEffect(data[index].effect);
    user.figure.render();
  }
});// @hash v3-7CF5C135D3AC74B516FF48A94915302BBB1CC710
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
SocketMessages.register("OnRoomSettingsUpdate", function (data) {
  for (let key in data) RoomInterface.data[key] = data[key];

  if (data.map != undefined || data.floor_material != undefined || data.wall_material != undefined) {
    if (RoomInterface.map != undefined) RoomInterface.entity.removeEntity(RoomInterface.map);
    RoomInterface.map = new Client.rooms.items.map(RoomInterface.entity, RoomInterface.data.map.floor, RoomInterface.data.map.door, {
      thickness: RoomInterface.data.floor_thickness,
      material: RoomInterface.data.floor_material
    }, {
      thickness: RoomInterface.data.wall_thickness,
      material: RoomInterface.data.wall_material
    });
    RoomInterface.map.render().then(function () {
      RoomInterface.entity.addEntity(RoomInterface.map);
    });
  }
});// @hash v3-DDE2A41A1978090727BF13FD60E62D4B42A6F530
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
RoomInterface.furniture = new function () {
  this.logics = {};
}();// @hash v3-79EA74EAB303996685EBD5838C18EB8891B6DF5C
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
RoomInterface.furniture.place = new function () {
  this.enabled = false;
  this.icon = document.createElement("canvas");
  this.icon.style.position = "fixed";
  this.icon.style.pointerEvents = "none";

  this.start = async function (furniture, finished, direction = null) {
    furniture = await Furnitures.get(furniture);
    if (finished == undefined) console.trace("finished is missing");
    this.furniture = furniture;
    this.map = await SocketMessages.sendCall({
      OnRoomMapStackUpdate: null
    }, "OnRoomMapStackUpdate");
    this.enabled = true;
    this.finished = finished;
    this.entity = new Client.rooms.items.furniture(RoomInterface.entity, furniture.id, direction);
    this.entity.furniture.events.render.push(function () {
      RoomInterface.furniture.place.direction = RoomInterface.furniture.place.entity.furniture.direction;
    });
    this.entity.disable();
    this.entity.alpha = 0.5;
    const renderer = new FurnitureRenderer({
      id: furniture.id,
      size: 1
    }, this.icon);
    await this.entity.render();
    RoomInterface.element.append(this.icon);
    RoomInterface.entity.addEntity(this.entity);
    this.showIcon();
    RoomInterface.cursor.events.hover.push(this.hover);
    RoomInterface.cursor.events.unhover.push(this.unhover);
    RoomInterface.entity.canvas.canvas.addEventListener("wheel", this.scroll);
  };

  this.hover = function (position) {
    const dimensions = RoomInterface.furniture.place.entity.furniture.getDimensions();

    for (let row = 0; row < dimensions.row; row++) {
      if (RoomInterface.furniture.place.map[position.row + row] == undefined) {
        RoomInterface.furniture.place.showIcon();
        return;
      }

      for (let column = 0; column < dimensions.column; column++) {
        if (RoomInterface.furniture.place.map[position.row + row][position.column + column] == undefined) {
          RoomInterface.furniture.place.showIcon();
          return;
        }
      }
    }

    RoomInterface.furniture.place.hideIcon();
    RoomInterface.furniture.place.position = position;
    RoomInterface.furniture.place.entity.setCoordinates(position.row, position.column, RoomInterface.furniture.place.map[position.row][position.column], 0);
    RoomInterface.furniture.place.entity.enable();
  };

  this.showIcon = function () {
    if (RoomInterface.furniture.place.iconShown == true) return;
    RoomInterface.furniture.place.entity.disable();
    RoomInterface.furniture.place.iconShown = true;
    RoomInterface.entity.canvas.canvas.addEventListener("mousemove", RoomInterface.furniture.place.move);
  };

  this.hideIcon = function () {
    if (RoomInterface.furniture.place.iconShown == false) return;
    RoomInterface.furniture.place.iconShown = false;
    RoomInterface.entity.canvas.canvas.removeEventListener("mousemove", RoomInterface.furniture.place.move);
    RoomInterface.furniture.place.icon.style.display = "none";
  };

  this.click = function () {
    RoomInterface.furniture.place.finished(RoomInterface.furniture.place);
  };

  this.move = function (event) {
    RoomInterface.furniture.place.icon.style.left = event.offsetX;
    RoomInterface.furniture.place.icon.style.top = event.offsetY;
    RoomInterface.furniture.place.icon.style.display = "block";
  };

  this.unhover = function () {
    RoomInterface.furniture.place.entity.disable();
    RoomInterface.furniture.place.showIcon();
  };

  this.scroll = async function (event) {
    const direction = event.originalEvent.deltaY < 0 ? 1 : 0;
    RoomInterface.furniture.place.entity.furniture.settings.direction = RoomInterface.furniture.place.entity.furniture.getNextDirection();
    await RoomInterface.furniture.place.entity.furniture.render();
  };

  this.bind = function () {
    RoomInterface.furniture.place.showIcon();
    RoomInterface.cursor.events.hover.push(RoomInterface.furniture.place.hover);
    RoomInterface.cursor.events.unhover.push(RoomInterface.furniture.place.unhover);
    RoomInterface.entity.canvas.canvas.addEventListener("wheel", RoomInterface.furniture.place.scroll);
    RoomInterface.element.append(RoomInterface.furniture.place.icon);
  };

  this.unbind = function () {
    RoomInterface.furniture.place.hideIcon();
    RoomInterface.cursor.events.hover.splice(RoomInterface.cursor.events.hover.indexOf(RoomInterface.furniture.place.hover), 1);
    RoomInterface.cursor.events.unhover.splice(RoomInterface.cursor.events.unhover.indexOf(RoomInterface.furniture.place.unhover), 1);
    RoomInterface.entity.canvas.canvas.removeEventListener("wheel", RoomInterface.furniture.place.scroll);
    RoomInterface.furniture.place.icon.remove();
  };

  this.stop = function () {
    this.enabled = false;
    this.unbind();
    RoomInterface.entity.removeEntity(RoomInterface.furniture.place.entity);
  };
}();// @hash v3-23DE637337B78A75AA79379B6D080F357992FDE2
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
RoomInterface.furniture.pickup = new function () {
  this.start = async function (entity) {
    entity.alpha = .5;
    const response = await SocketMessages.sendCall({
      OnRoomFurniturePickup: entity.data.id
    }, "OnRoomFurniturePickup", x => x.id == entity.data.id);
  };
}();// @hash v3-E75F6C0E4AC0124213CD162A49F6A0FABDDEFE51
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
RoomInterface.furniture.move = new function () {
  this.start = async function (entity) {
    entity.disable();
    RoomInterface.furniture.place.start(entity.data.furniture, function (result) {
      if (result.entity.enabled == false) {
        result.stop();
        entity.enable();
        return;
      }

      result.unbind();
      SocketMessages.sendCall({
        OnRoomFurnitureMove: {
          id: entity.data.id,
          position: {
            row: result.position.row,
            column: result.position.column,
            direction: result.entity.furniture.settings.direction
          }
        }
      }, "OnRoomFurnitureMove").then(function (response) {
        result.stop();
        entity.enable();
        if (response != null) entity.setCoordinates(result.position.row, result.position.column, result.position.depth);
      });
    }, entity.furniture.settings.direction);
  };
}();// @hash v3-FB3C77A44E053048045F0F34DC35E45F284983C1
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
RoomInterface.furniture.rotate = new function () {
  this.start = async function (entity) {
    await SocketMessages.sendCall({
      OnRoomFurnitureRotate: {
        id: entity.data.id,
        direction: entity.furniture.getNextDirection()
      }
    }, "OnRoomFurnitureRotate", x => x.id == entity.data.id);
  };
}();// @hash v3-FF2A8D8A3E000179EDC9568A0C25008081EF4A18
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
RoomInterface.furniture.use = new function () {
  this.start = async function (entity, sprite) {
    if (RoomInterface.furniture.logics[entity.furniture.types.logic] != undefined) RoomInterface.furniture.logics[entity.furniture.types.logic](entity, sprite);else RoomInterface.furniture.logics["furniture_basic"](entity, sprite);
  };
}();// @hash v3-C20F6438D25C4985FD38C388E1556F9ECF3C04DA
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
RoomInterface.furniture.logics.furniture_multistate = async function (entity) {
  const animation = entity.furniture.getNextAnimation();
  await SocketMessages.sendCall({
    OnRoomFurnitureUse: {
      id: entity.data.id,
      animation
    }
  }, "OnRoomFurnitureUse", x => x == entity.data.id);
  entity.furniture.setAnimation(animation);
};// @hash v3-E9AAD579E1D77CB2DD536389F2C594DFB2091774
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
RoomInterface.furniture.logics.furniture_custom_stack_height = function (entity) {
  if (entity.dialog != undefined) {
    entity.dialog.show();
    return;
  }

  entity.dialog = new Dialog({
    title: entity.furniture.furniture.title,
    size: {
      width: 240,
      height: 120
    },
    offset: {
      type: "center"
    }
  });
  entity.dialog.events.destroy.push(function () {
    entity.dialog = undefined;
  });
  entity.dialog.show();
};// @hash v3-2FA4D4B773F42E02A3D0460C88C0FECAB6EFE6DC
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
RoomInterface.furniture.logics.furniture_basic = async function (entity, sprite) {
  const tag = sprite == undefined ? undefined : sprite.tag;
  await SocketMessages.sendCall({
    OnRoomFurnitureUse: {
      id: entity.data.id,
      tag
    }
  }, "OnRoomFurnitureUse", x => x == entity.data.id);
};// @hash v3-1FF2FEBB2AB64673D7C4CF7AFDA0EFE941E79D79
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
RoomInterface.furniture.logics.furniture_video = new function () {
  const entity = new Dialog({
    title: "Room Furniture Video",
    size: {
      width: 800,
      height: 256
    },
    offset: {
      type: "center"
    },
    resizable: true
  });
  entity.events.create.push(function () {
    entity.content.classList.add("room-interface-furniture-video");
    entity.frame = document.createElement("iframe");
    entity.frame.outerHTML = `
            <iframe frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
        `;
    entity.content.append(entity.frame);
    entity.controls = document.createElement("div");
    entity.controls.className = "room-interface-furniture-controls";
    entity.content.append(entity.controls);
    const input = document.createElement("div");
    input.className = "room-interface-furniture-input";
    input.innerHTML = `
            <p class="room-interface-furniture-input-text">https://www.youtube.com/watch?v=</p>

            <input type="text" placeholder="dQw4w9WgXcQ">
        `;
    entity.controls.append(input);
    const link = input.querySelector("input");
    const plus = document.createElement("div");
    plus.className = "sprite-plus";
    plus.addEventListener("click", async () => {
      const value = link.value;
      if (value.length == 0) return;
      entity.pause();
      const result = await SocketMessages.sendCall({
        OnRoomFurnitureUse: {
          id: entity.data.id,
          video: value,
          action: "add"
        }
      }, "OnRoomFurnitureUse");
      entity.unpause();
      link.value = "";
      if (result) SocketMessages.send({
        OnRoomFurnitureUse: {
          id: entity.data.id
        }
      });
    });
    input.appendChild(plus);
    entity.videos = document.createElement("div");
    entity.videos.className = "room-interface-furniture-videos";
    entity.controls.append(entity.videos);
    entity.buttons = document.createElement("div");
    entity.buttons.className = "room-interface-furniture-buttons";
    entity.controls.append(entity.buttons);
    const previous = document.createElement("div");
    previous.className = "room-interface-furniture-player";
    previous.innerHTML = `<i class="sprite-player-previous"></i>`;
    previous.appendChild("click", async () => {
      entity.pause();
      await SocketMessages.sendCall({
        OnRoomFurnitureUse: {
          id: entity.data.id,
          action: "previous"
        }
      }, "OnRoomFurnitureUse");
      entity.unpause();
    });
    entity.buttons.append(previous);
    const stop = document.createElement("div");
    stop.className = "room-interface-furniture-player";
    stop.innerHTML = `<i class="sprite-player-stop"></i>`;
    stop.appendChild("click", async () => {
      entity.pause();
      await SocketMessages.sendCall({
        OnRoomFurnitureUse: {
          id: entity.data.id,
          action: "stop"
        }
      }, "OnRoomFurnitureUse");
      entity.unpause();
    });
    entity.buttons.append(stop);
    const pause = document.createElement("div");
    pause.className = "room-interface-furniture-player";
    pause.innerHTML = `<i class="sprite-player-pause"></i>`;
    pause.appendChild("click", async () => {
      entity.pause();
      await SocketMessages.sendCall({
        OnRoomFurnitureUse: {
          id: entity.data.id,
          action: "pause"
        }
      }, "OnRoomFurnitureUse");
      entity.unpause();
    });
    entity.buttons.append(pause);
    const next = document.createElement("div");
    next.className = "room-interface-furniture-player";
    next.innerHTML = `<i class="sprite-player-next"></i>`;
    next.appendChild("click", async () => {
      entity.pause();
      await SocketMessages.sendCall({
        OnRoomFurnitureUse: {
          id: entity.data.id,
          action: "next"
        }
      }, "OnRoomFurnitureUse");
      entity.unpause();
    });
    entity.buttons.append(next);
  });
  entity.events.show.push(function () {
    entity.videos.innerHTML = "";
    const furniture = RoomInterface.furnitures[entity.data.id];
    Furnitures.get(furniture.data.furniture).then(function (info) {//entity.setTitle(info.title);
    });

    for (let index in entity.data.videos) {
      const minutes = Math.floor(entity.data.videos[index].length / 60);
      const seconds = entity.data.videos[index].length - minutes * 60;
      const video = document.createElement("div");
      video.className = "room-interface-furniture-video-item";
      video.innerHTML = `
                <div class="room-interface-furniture-video-item-title"><b>${entity.data.videos[index].title}</b></div>
                <p class="room-interface-furniture-video-item-user">By ${entity.data.videos[index].author}</p>

                <div class="room-interface-furniture-video-item-length">${minutes}:${seconds < 10 ? "0" + seconds : seconds}</div>
            `;
      entity.videos.append(video);
      const reference = document.createElement("div");
      reference.className = "sprite-reference";
      video.querySelector(".room-interface-furniture-video-item-title").append(reference);
      reference.addEventListener("click", () => {
        window.open("https://www.youtube.com/watch?v=" + entity.data.videos[index].id);
      });
      video.addEventListener("click", e => {
        if (!e.target.classList.contains("room-interface-furniture-video-item")) return;
        video.parentElement.querySelector(".room-interface-furniture-video-item.active").classList.remove("active");
        video.classList.add("active");
        entity.frame.src = "https://www.youtube.com/embed/" + entity.data.videos[index].id;
      });
      const cross = document.createElement("div");
      cross.className = "sprite-cross";
      video.append(cross);
      cross.addEventListener("click", async () => {
        entity.pause();
        await SocketMessages.sendCall({
          OnRoomFurnitureUse: {
            id: entity.data.id,
            video: entity.data.videos[index].id,
            action: "remove"
          }
        }, "OnRoomFurnitureUse");
        entity.frame.src = "";
        video.remove();
        entity.unpause();
      });
    }

    entity.videos.querySelector(".room-interface-furniture-video-item").click();
  });
  return entity;
}();
SocketMessages.register("OnRoomFurnitureVideoUse", function (data) {
  RoomInterface.furniture.logics.furniture_video.data = data;
  RoomInterface.furniture.logics.furniture_video.show();
});// @hash v3-F1360A8882E82FE8A729E0335862A07EFF70C0F1
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
RoomInterface.camera = new function () {
  const entity = new CameraDialog({
    title: "Room Camera",
    size: {
      width: 340,
      height: 462
    },
    offset: {
      type: "center"
    }
  });
  return entity;
}();// @hash v3-E87CF5DC16F518F22BFCE542E09C996FC763929E
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
Client.rooms.navigator = new function () {
  const entity = new Dialog({
    title: "Room Navigator",
    size: {
      width: 420,
      height: "auto"
    },
    offset: {
      type: "center",
      top: -250
    },
    resizable: true
  });
  entity.events.create.push(function () {
    entity.header = new DialogHeader();
    entity.content.append(entity.header.element);
    entity.tabs = new DialogTabs(400);
    entity.tabs.add("public", "Public", function (element) {
      entity.header.setTitle("Public Lounges!");
      entity.header.setDescription("");
      const icon = document.createElement("div");
      icon.className = "room-navigator-public-sprite";
      entity.header.setIcon(icon);
    });
    entity.tabs.add("all_rooms", "All Rooms", function (element) {
      entity.header.setTitle("Explore a new room!");
      entity.header.setDescription("Explore a new culture with each and every room you enter and meet different kind of people!");
      const icon = document.createElement("div");
      icon.className = "room-navigator-explore-sprite";
      entity.header.setIcon(icon);
    });
    entity.tabs.add("events", "Events", function (element) {
      entity.header.setTitle("Publish an event!");
      entity.header.setDescription("Public an event to advertise your room and gain interest!");
      const icon = document.createElement("div");
      icon.className = "room-navigator-event-sprite";
      entity.header.setIcon(icon);
    });
    entity.tabs.add("my_rooms", "My Rooms", async function (element) {
      entity.header.setTitle("Create your own room!");
      entity.header.setDescription("Create and furnish your own room to just your likings and show it off to your friends!");
      const icon = document.createElement("div");
      icon.className = "room-navigator-create-sprite";
      entity.header.setIcon(icon);
    });
    entity.tabs.click(async function (identifier, element) {
      entity.pause();
      const rooms = await SocketMessages.sendCall({
        "OnRoomNavigatorUpdate": identifier
      }, "OnRoomNavigatorUpdate");

      for (let key in rooms) {
        const list = new Client.rooms.navigator.list({
          title: key,
          active: true
        });
        rooms[key] = rooms[key].sort(function (a, b) {
          if (a.users == undefined) return 1;
          if (b.users == undefined) return -1;
          return b.users - a.users;
        });

        for (let index in rooms[key]) list.add(rooms[key][index]);

        element.append(list.element);
      }

      entity.unpause();
    });
    entity.home = document.createElement("div");
    entity.home.className = "room-navigator-tab-icon room-navigator-tab-home";
    entity.home.addEventListener("click", () => {
      SocketMessages.send({
        OnRoomNavigatorEnter: Client.user.home
      });
    });
    entity.tabs.header.append(entity.home);
    const create = document.createElement("div");
    create.className = "room-navigator-tab-icon room-navigator-tab-create";
    create.addEventListener("click", () => {
      RoomCreation.toggle();
    });
    entity.tabs.header.append(create);
    console.log(entity.tabs.header);
    entity.tabs.show("my_rooms");
    entity.content.append(entity.tabs.element);
  });
  entity.events.show.push(function () {
    //if(Client.user.home == null)
    entity.home.style.display = "none"; //else
    //    entity.$home.show();

    entity.tabs.show();
  });
  return entity;
}();// @hash v3-A32AC335104AF33B9D7B1338E0E9717743D3FA90
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
Client.rooms.navigator.list = function (settings) {
  this.element = document.createElement("div");
  this.element.className = "room-navigator-list";
  this.element.innerHTML = `
        <div class="room-navigator-list-header">
            <div class="room-navigator-list-toggle"></div>

            <p class="room-navigator-list-title"></p>

            <div class="room-navigator-list-expand"></div> 
        </div>

        <div class="room-navigator-list-table"></div>
    `;
  this.table = this.element.querySelector(".room-navigator-list-table");
  this.settings = {
    active: false,
    title: "",
    count: 0,
    collapsed: false
  };

  this.set = function (settings) {
    if (settings.title != undefined) this.element.querySelector(".room-navigator-list-title").innerHTML = settings.title;

    if (settings.active != undefined) {
      if (settings.active) this.element.setAttribute("active", "");else this.element.removeAttribute("active");
    }

    for (let key in settings) this.settings[key] = settings[key];
  };

  this.set(settings);

  this.add = function (settings) {
    const room = {
      users: 0,
      title: "Unknown title..."
    };

    for (let key in settings) room[key] = settings[key];

    let color = "#CAC9C0";

    if (room.users > 0) {
      color = "#62B061";
    }

    this.settings.count++;
    const element = document.createElement("div");
    element.className = "room-navigator-list-item";
    element.innerHTML = `
            <div class="room-navigator-list-users" style="background: ${color}">
                <p class="room-navigator-list-users-count">
                    <i></i> ${room.users}
                </p>
            </div>
            ${room.title}
        `;
    this.table.append(element);
    Game.getUser(room.user).then(function (user) {
      const owner = document.createElement("div");
      owner.className = "room-navigator-list-owner";
      owner.innerHTML = `By ${user.name}`;
      element.append(owner);
    });
    element.addEventListener("click", async () => {
      SocketMessages.send({
        OnRoomNavigatorEnter: room.id
      });
    });

    if (this.settings.count > 10) {
      this.expandButton.style.display = "block";
      element.classList.add("room-navigator-list-expanded");
    }
  };

  this.expandButton = this.element.querySelector(".room-navigator-list-expand");
  this.expandButton.addEventListener("click", event => {
    if (this.settings.collapsed) {
      this.table.querySelector(".room-navigator-list-expanded").style.display = "none";
      this.expandButton.removeAttribute("active");
    } else {
      this.table.querySelector(".room-navigator-list-expanded").style.display = "block";
      this.expandButton.setAttribute("active", "");
    }

    this.settings.collapsed = !this.settings.collapsed;
  });
  this.element.querySelector(".room-navigator-list-toggle").addEventListener("click", event => {
    this.set({
      active: !this.settings.active
    });
  });
};// @hash v3-0C559E0DDDBB1BAC175DA62FE4D5CEEDC9A2A96C
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
SocketMessages.register("OnRoomNavigatorEnter", function (response) {});// @hash v3-83E9CCD59C94A80CAA9A5F52E6022572ACACAEC4
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
const RoomCreation = new class extends Dialog {
  constructor(settings = {}) {
    settings = {
      title: "Room Creation",
      size: {
        width: 580,
        height: 310
      },
      offset: {
        type: "center"
      }
    };
    super(settings);
    this.events.create.push(() => {
      console.error("create");
      this.element.style.overflow = "initial";
      this.content.classList.add("room-creation");
    });
    this.events.show.push(() => {
      console.error("show");
      Client.rooms.navigator.hide();
      this.settings = {};
      this.showProperties();
    });
    this.events.destroy.push(() => {
      if (RoomCreation.editor != undefined) {
        RoomCreation.editor.destroy();
        RoomCreation.editor = undefined;
      }
    });
  }

  async showProperties() {
    this.settings.properties = {};
    this.content.innerHTML = "";
    const grid = document.createElement("div");
    grid.className = "room-creation-grid";
    grid.innerHTML = `
            <div class="room-creation-information"></div>
        `;
    this.content.append(grid);
    const buttons = document.createElement("div");
    buttons.className = "room-creation-buttons";
    this.content.append(buttons);
    const information = grid.querySelector(".room-creation-information");
    let name = document.createElement("div");
    name.className = "room-creation-property";
    name.innerHTML = `
            <p>
                <b>Room Name</b>
                <span>Give your room a fun and interesting title, this is what interests others!</span> 
            </p>
            
            <div class="input-pen">
                <input type="text" class="room-creation-name" placeholder="Enter a room name...">
            </div> 
        `;
    name.querySelector(".room-creation-name").addEventListener("change", event => {
      this.settings.properties.title = event.target.value;
    });
    information.append(name);
    let description = document.createElement("div");
    description.className = "room-creation-property";
    description.innerHTML = `
            <p>
                <b>Room Description</b>
                <span>Describe what your room is, what can others do in your room, let them know what it is!</span> 
            </p>
            
            <div class="textarea-pen">
                <textarea type="text" class="room-creation-description" placeholder="Enter a room name..."></textarea>
            </div> 
        `;
    description.querySelector(".room-creation-description").addEventListener("change", event => {
      this.settings.properties.description = event.target.value;
    });
    information.append(description);
    const category = document.createElement("div");
    category.className = "room-creation-property";
    category.innerHTML = `
            <p>
                <b>Room Category</b>
                <span>What category does your room fall into?</span> 
            </p>
        `;
    information.append(category);
    const list = [];
    const categories = await RoomCategories.get();

    for (let index in categories) list.push({
      text: categories[index].name,
      value: categories[index].id
    });

    const selection = new DialogSelection("Select a room category...", list);
    category.append(selection.element);
    const privacy = document.createElement("div");
    privacy.className = "room-creation-privacy";
    grid.append(privacy);
    const locks = document.createElement("div");
    locks.className = "room-creation-property";
    locks.innerHTML = `
            <p>
                <b>Room Privacy</b>
                <span>Select whether you want a public, private, or passworded room!</span> 
            </p>

            <div class="input-lock">
                <input class="room-creation-password disabled" type="text" placeholder="Enter a room password...">
            </div> 
            
            <div class="room-creation-privacy-selection">
                <div class="room-creation-privacy-option active" value="0"> 
                    <div class="room-creation-privacy-public"></div>
                </div>
                
                <div class="room-creation-privacy-option" value="1"> 
                    <div class="room-creation-privacy-private"></div>
                </div>

                <div class="room-creation-privacy-option" value="2"> 
                    <div class="room-creation-privacy-password"></div>
                </div>
            </div>
        `;
    privacy.append(locks);
    const password = locks.querySelector(".room-creation-password");
    locks.querySelector(".room-creation-privacy-option").addEventListener("click", event => {
      locks.querySelector(".room-creation-privacy-option.active").classList.remove("active");
      event.target.classList.add("active");
      if (event.target.value != 2) password.classList.add("disabled");else password.classList.remove("disabled");
    });
    const next = document.createElement("div");
    next.className = "dialog-button";
    next.innerHTML = "Continue ";
    buttons.append(next);
    next.addEventListener("click", () => {
      this.showMap();
    });
  }

  async showMap() {
    this.content.innerHTML = "";
    this.settings.map = {};
    const models = await SocketMessages.sendCall({
      OnRoomModelsUpdate: null
    }, "OnRoomModelsUpdate");
    const tabs = new DialogTabs(231);
    tabs.add("default", "Default Maps", element => {
      if (RoomCreation.editor != undefined) {
        RoomCreation.editor.destroy();
        RoomCreation.editor = undefined;
      }

      element.parentElement.style.overflow = "auto";
      const roomCreationModels = document.createElement("div");
      roomCreationModels.className = "room-creation-models";
      element.append(roomCreationModels);

      for (let index in models) {
        const map = models[index].map.split('|');
        let tiles = 0;

        for (let row in map) for (let column in map[row]) {
          if (map[row][column] != 'X') tiles++;
        }

        const element = document.createElement("div");
        element.className = "dialog-item room-creation-model";
        element.innerHTML = `
                    <p class="room-creation-model-tiles">${tiles} tiles</div>
                `;
        roomCreationModels.append(element);
        element.prepend(new RoomCreationMap(map, models[index].door));
        element.addEventListener("click", () => {
          roomCreationModels.querySelector(".room-creation-model.active")?.classList.remove("active");
          element.classList.add("active");
          this.settings.map = models[index];
        });
        if (this.settings.map.id == undefined || this.settings.map.id == models[index].id) element.click();
      }
    });
    tabs.add("editor", "Map Editor", element => {
      element.parentElement.style.overflow = "visible";
      const grid = document.createElement("div");
      grid.className = "room-creation-map";
      element.append(grid);
      const settings = document.createElement("div");
      settings.className = "room-creation-properties";
      settings.style.display = "grid";
      settings.style.paddingbottom = "12px";
      settings.innerHTML = `
                <div class="room-creation-property">
                    <p>
                        <b>Map Editor</b>
                        <span>Use your mouse on the renderer to the left!</span><br><br>
                        <span>Hold shift and left click to use the current selected tool on the editor.</span><br><br>
                        <span>Press right click to copy the depth of an existing tile on the editor.</span> 
                    </p>
                </div>
            `;
      grid.append(settings);
      const toolsProperty = document.createElement("div");
      toolsProperty.className = "room-creation-property";
      toolsProperty.style.margin = "auto 0 0";
      toolsProperty.innerHTML = `
                <p>
                    <b>Map Tools</b>
                    <span>Select what tool you want to use on the editor:</span> 
                </p>

                <div class="room-creation-editor-tools"></div>
            `;
      settings.append(toolsProperty);
      const tools = toolsProperty.querySelector(".room-creation-editor-tools");
      const data = {
        map: this.settings.map.map.split('|'),
        door: {
          row: this.settings.map.door.row,
          column: this.settings.map.door.column
        }
      };
      const editor = new Client.rooms.editor(data, map => {
        this.settings.map.map = map; //const $canvas = new RoomCreationMap(map.split('|'), this.settings.map.door);
        //$settings.html($canvas);
      });
      RoomCreation.editor = editor;
      editor.tiles.element.style.width = "280px";
      editor.tiles.element.style.height = "230px";
      grid.prepend(editor.tiles.element);
      editor.depth.element.style.width = "280px";
      editor.depth.element.style.height = "24px";
      editor.tiles.element.append(editor.depth.element);
      editor.depth.render();
      const add = document.createElement("div");
      add.className = "dialog-item";
      add.value = 0;
      add.append(editor.tools.add);
      tools.append(add);
      const remove = document.createElement("div");
      remove.className = "dialog-item";
      remove.value = 1;
      remove.append(editor.tools.remove);
      tools.append(remove);
      const up = document.createElement("div");
      up.className = "dialog-item";
      up.value = 2;
      up.append(editor.tools.up);
      tools.append(up);
      const down = document.createElement("div");
      down.className = "dialog-item";
      down.value = 3;
      down.append(editor.tools.down);
      tools.append(down);
      const door = document.createElement("div");
      door.className = "dialog-item";
      door.value = 4;
      door.append(editor.tools.door);
      tools.append(door);
      const toolItems = tools.getElementsByClassName("dialog-item");

      for (let index = 0; index < toolItems.length; index++) {
        toolItems[index].addEventListener("click", ".dialog-item", () => {
          tools.querySelector(".dialog-item.active").classList.remove("active");
          toolItems[index].addClass("active");
          editor.tools.setTool(toolItems[index].value);
        });
      }

      add.click();
    });
    tabs.show("default");
    this.content.append(tabs.element);
    const buttons = document.createElement("div");
    buttons.className = "room-creation-buttons";
    this.content.append(buttons);
    const back = document.createElement("div");
    back.className = "dialog-button";
    back.innerHTML = " Back";
    back.addEventListener("click", () => this.showProperties());
    buttons.append(back);
    const next = document.createElement("div");
    next.className = "dialog-button";
    next.innerHTML = "Continue ";
    next.addEventListener("click", async () => {
      await SocketMessages.sendCall({
        OnRoomModelCreate: this.settings
      }, "OnRoomModelCreate");
      this.hide();
    });
    buttons.append(next);
  }

}();// @hash v3-27831D8589416A5D62490AD66CF8FD90976F1A18
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
const RoomCreationMap = function (input, door) {
  const canvas = document.createElement("canvas");
  const context = canvas.getContext("2d");
  let map = [],
      rows = input.length,
      columns = 0,
      maxDepth = 0;

  for (let row in input) {
    if (input[row].length > columns) columns = input[row].length;
    map[row] = [];

    for (let column in input[row]) {
      if (input[row][column] == 'X') {
        map[row][column] = 'X';
        continue;
      }

      map[row][column] = !Client.utils.isLetter(input[row][column]) ? parseInt(input[row][column]) : Client.utils.fromCharCode(input[row][column]);
      if (map[row][column] > maxDepth) maxDepth = map[row][column];
    }
  }

  context.canvas.width = rows * 4 + columns * 4 + 2;
  context.canvas.height = rows * 2 + columns * 2 + maxDepth * 4 + 6 + 2;
  context.imageSmoothingEnabled = false;

  for (let row in map) {
    for (let column in map[row]) {
      if (map[row][column] == 'X') continue;
      if (door.row == row && door.column == column) continue;
      const depth = map[row][column];
      let left = 0,
          top = 0,
          hasPrevious = false;
      context.setTransform(1, .5, -1, .5, rows * 4 + 4, maxDepth * 4 + 6 + 1);
      context.fillStyle = "#A57B51";
      left = column * 4 - depth * 4;
      top = row * 4 - depth * 4;
      context.fillRect(left, top, 4.5, 4.5);
      hasPrevious = false;

      for (let previousColumn = column - 1; previousColumn != -1; previousColumn--) {
        if (map[row][previousColumn] == undefined || map[row][previousColumn] == 'X') {
          for (let previousRow = row - 1; previousRow != -1; previousRow--) {
            if (map[previousRow] == undefined || map[previousRow][previousColumn] == 'X') continue;
            if (door.row == previousRow && door.column == previousColumn) continue;
            hasPrevious = true;
            break;
          }

          if (hasPrevious) break;
          continue;
        }

        if (door.row == row && door.column == previousColumn) continue;
        hasPrevious = true;
        break;
      }

      if (!hasPrevious) {
        context.setTransform(1, -.5, 0, 1, rows * 4 + 4, maxDepth * 4 + 6 + 1);
        context.fillStyle = "#D48612";
        left = -(row * 4) + (column - 1) * 4;
        top = (column - 1) * 4 - depth * 4;
        context.fillRect(left, top - 5.5, 4.5, door.row == row && door.column == parseInt(column) - 1 ? 1 : 9);
      }

      hasPrevious = false;

      for (let previousRow = row - 1; previousRow != -1; previousRow--) {
        if (map[previousRow] == undefined || map[previousRow][column] == 'X') {
          for (let previousColumn = column - 1; previousColumn != -1; previousColumn--) {
            if (map[previousRow][previousColumn] == undefined || map[previousRow][previousColumn] == 'X') continue;
            if (door.row == previousRow && door.column == previousColumn) continue;
            hasPrevious = true;
            break;
          }

          if (hasPrevious) break;
          continue;
        }

        if (door.row == previousRow && door.column == column) continue;
        hasPrevious = true;
        break;
      }

      if (!hasPrevious) {
        context.setTransform(1, .5, 0, 1, rows * 4 + 4, maxDepth * 4 + 6 + 1);
        context.fillStyle = "#F0C032";
        left = column * 4 - row * 4;
        top = row * 4 - depth * 4;
        context.fillRect(left, top - 9.5, 4.5, door.row == parseInt(row) - 1 && door.column == column ? 1 : 9);
      }
    }
  }

  context.resetTransform();
  context.globalCompositeOperation = "destination-over";
  context.filter = "brightness(0%)";
  context.globalAlpha = .75;
  context.drawImage(context.canvas, 1, 0);
  context.drawImage(context.canvas, -1, 0);
  context.drawImage(context.canvas, 0, 1);
  return canvas;
};// @hash v3-51B0E91524D605E20FB784324A2D420D8CD2A0C8
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
Client.rooms.editor = function (settings, change) {
  let editorDepth = 0,
      editorTool = 0;
  this.tiles = new function () {
    this.element = document.createElement("div");
    this.element.className = "room-editor-tiles";
    this.element.innerHTML = `
            <canvas class="room-editor-tiles"></canvas>
        `;
    const canvasElement = this.element.querySelector(".room-editor-tiles");
    let map = settings.map,
        rows = map.length,
        columns = 0,
        renderOffset = {
      left: 0,
      top: 0
    };

    for (let row in map) {
      map[row] = map[row].split('');
      if (map[row].length > columns) columns = map[row].length;

      for (let column in map[row]) {
        if (map[row][column] == 'X') continue;
        map[row][column] = !Client.utils.isLetter(map[row][column]) ? parseInt(map[row][column]) : Client.utils.fromCharCode(map[row][column]);
      }
    }

    const render = function (canvas) {
      const context = canvas.getContext("2d");
      context.canvas.width = canvas.parentElement.clientWidth;
      context.canvas.height = canvas.parentElement.clientHeight;
      renderOffset = {
        left: canvas.offset.left,
        top: canvas.offset.top
      };
      context.setTransform(1, .5, -1, .5, renderOffset.left, renderOffset.top);

      for (let row in map) {
        for (let column in map[row]) {
          if (map[row][column] == 'X') continue;
          context.fillStyle = "hsl(" + (360 - 360 / 100 * (34 + map[row][column] * 2.5)) + ", 100%, 50%)";
          context.fillRect(parseInt(column) * 16, parseInt(row) * 16, 15.5, 15.5);
        }
      }

      context.strokeStyle = "white";
      context.lineWidth++;
      context.strokeRect(settings.door.column * 16, settings.door.row * 16, 15.5, 15.5);
    };

    this.canvas = new Canvas(canvasElement, {
      render,
      draggable: true,
      offset: {
        left: canvasElement.width / 2,
        top: canvasElement.height / 2 - rows * 4
      }
    });
    let down = false,
        lastCoordinate = {
      row: null,
      column: null
    },
        timestamp = performance.now();
    canvasElement.addEventListener("mousedown", () => {
      if (this.canvas.draggableEnabled && performance.now() - this.canvas.draggableTimestamp > 200) return;
      if (!Keys.down["ShiftLeft"]) return;
      down = true;
    });
    canvasElement.addEventListener("mouseup", () => {
      down = false;
    });
    canvasElement.addEventListener("mousemove", event => {
      const innerPosition = {
        left: (event.offsetX - this.canvas.offset.left) * 0.5 + (event.offsetY - this.canvas.offset.top),
        top: (event.offsetX - this.canvas.offset.left) * -0.5 + (event.offsetY - this.canvas.offset.top)
      };
      const coordinate = {
        row: Math.floor(innerPosition.top / 16),
        column: Math.floor(innerPosition.left / 16)
      };

      if (event.type == "mousemove") {
        if (!down) return;
        if (performance.now() - timestamp < 10) return;
        timestamp = performance.now();
        if (lastCoordinate.row == coordinate.row && lastCoordinate.column == coordinate.column) return;
        lastCoordinate = coordinate;
      } else if (!Keys.down["ShiftLeft"]) return;

      let extra = null;

      if (editorTool == 0) {
        if (map[coordinate.row] == undefined) {
          map[coordinate.row] = [];

          if (coordinate.row < 0) {
            this.canvas.offset.top -= 8;
            this.canvas.offset.left += 16;
          }
        } else if (map[coordinate.row][coordinate.column] == undefined) {
          let hasColumn = false;

          for (let row in map) for (let column in map[row]) {
            if (parseInt(column) == coordinate.column) {
              hasColumn = true;
              break;
            }
          }

          if (!hasColumn) {
            if (coordinate.column < 0) {
              this.canvas.offset.top -= 8;
              this.canvas.offset.left -= 16;
            }
          }
        }

        extra = {
          rows: 0,
          columns: 0
        };

        if (coordinate.row >= 0) {
          if (coordinate.column >= 0) {
            if (map[coordinate.row][coordinate.column] == editorDepth) return;
          }

          for (let row = coordinate.row - 1; row != -1; row--) if (map[row] == undefined) map[row] = [];
        } else {
          const margin = coordinate.row * -1;
          extra.rows = margin;
          const newMap = [];
          settings.door.row += margin;

          for (let row in map) newMap[parseInt(row) + margin] = map[row];

          coordinate.row = 0;

          for (let row = 0; row != margin; row++) if (newMap[row] == undefined) newMap[row] = [];

          map = newMap;
        }

        if (coordinate.column >= 0) {
          for (let column = coordinate.column - 1; column != -1; column--) {
            if (map[coordinate.row][column] == undefined) map[coordinate.row][column] = 'X';
          }
        } else {
          const margin = coordinate.column * -1;
          extra.columns = margin;
          settings.door.column += margin;

          for (let row in map) {
            const newMap = [];

            for (let column in map[row]) newMap[margin + parseInt(column)] = map[row][column];

            for (let column = 0; column != margin; column++) if (newMap[column] == undefined) newMap[column] = 'X';

            map[row] = newMap;
          }

          coordinate.column += margin;
        }

        map[coordinate.row][coordinate.column] = editorDepth;
      } else if (editorTool == 1) {
        if (map[coordinate.row] == undefined) return;
        if (map[coordinate.row][coordinate.column] == undefined) return;
        if (map[coordinate.row][coordinate.column] == 'X') return;
        map[coordinate.row][coordinate.column] = 'X';
      } else if (editorTool == 2) {
        if (map[coordinate.row] == undefined) return;
        if (map[coordinate.row][coordinate.column] == undefined) return;
        if (map[coordinate.row][coordinate.column] == 24) return;
        if (map[coordinate.row][coordinate.column] == 'X') return;
        map[coordinate.row][coordinate.column]++;
      } else if (editorTool == 3) {
        if (map[coordinate.row] == undefined) return;
        if (map[coordinate.row][coordinate.column] == undefined) return;
        if (map[coordinate.row][coordinate.column] == 0) return;
        if (map[coordinate.row][coordinate.column] == 'X') return;
        map[coordinate.row][coordinate.column]--;
      } else if (editorTool == 4) {
        if (map[coordinate.row] == undefined) return;
        if (map[coordinate.row][coordinate.column] == undefined) return;
        if (map[coordinate.row][coordinate.column] == 'X') return;
        if (coordinate.row == settings.door.row && coordinate.column == settings.door.column) return;
        settings.door.row = coordinate.row;
        settings.door.column = coordinate.column;
      }

      rows = map.length, columns = 0;

      for (let row in map) for (let column in map[row]) {
        if (column > columns) columns = column;
      }

      for (let row in map) {
        for (let column = 0; column <= columns; column++) {
          if (map[row][column] == undefined) map[row][column] = 'X';
        }
      }

      let result = "";

      for (let row in map) {
        if (result.length != 0) result += "|";

        for (let column in map[row]) {
          if (map[row][column] != 'X' && parseInt(map[row][column]) > 10) result += Client.utils.charCode(parseInt(map[row][column]) - 10);else result += map[row][column];
        }
      }

      change(result, extra);
    });
  }();
  this.depth = new function () {
    this.element = document.createElement("div");
    this.element.className = "room-editor-depth";
    this.element.innerHTML = `
            <canvas class="room-editor-depth-canvas"></canvas>

            <div class="room-editor-depth-cursor"></div>
        `;
    const canvas = this.element.querySelector(".room-editor-depth-canvas");
    const cursor = this.element.querySelector(".room-editor-depth-cursor");

    const setCursor = function (depth) {
      const width = canvas.parentElement.width / 24;
      cursor.style.left = `${width / 2 + width * depth}px`;
      editorDepth = depth;
    };

    this.render = function () {
      const context = canvas.getContext("2d");
      context.canvas.width = canvas.parentElement.width;
      context.canvas.height = canvas.parentElement.height;
      const steps = 24,
            width = context.canvas.width / steps;

      for (let index = 0; index < steps; index++) {
        context.fillStyle = "hsl(" + (360 - 360 / 100 * (34 + index * 2.5)) + ", 100%, 50%)";
        const path = new Path2D();
        path.rect(width * index, 0, width + .5, context.canvas.height);
        paths[index] = path;
        context.fill(path);
      }

      setCursor(editorDepth);
    };

    let paths = {},
        down = false;
    this.element.addEventListener("mousedown", event => {
      down = true;
      const context = canvas.getContext("2d");

      for (let depth in paths) {
        if (!context.isPointInPath(paths[depth], event.offsetX, event.offsetY)) continue;
        setCursor(depth);
        break;
      }
    });
    this.element.addEventListener("mousemove", event => {
      if (!down) return;
      const context = canvas.getContext("2d");

      for (let depth in paths) {
        if (!context.isPointInPath(paths[depth], event.offsetX, event.offsetY)) continue;
        setCursor(depth);
        break;
      }
    });
    this.element.addEventListener("mouseup", () => {
      down = false;
    });
  }();
  this.tools = new function () {
    this.add = document.createElement("div");
    this.add.className = "room-editor-tile-add";
    this.remove = document.createElement("div");
    this.remove.className = "room-editor-tile-remove";
    this.up = document.createElement("div");
    this.up.className = "room-editor-tile-up";
    this.down = document.createElement("div");
    this.down.className = "room-editor-tile-down";
    this.door = document.createElement("div");
    this.door.className = "room-editor-tile-door";

    this.setTool = function (tool) {
      editorTool = tool;
    };
  }();

  this.destroy = function () {
    this.tiles.canvas.destroy();
  };
};// @hash v3-18FC9AD45DC4C0A68592DD7F8F3E860EB4676DB2
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
Client.rooms.settings = new function () {
  const entity = new Dialog({
    title: "Room Settings",
    size: {
      width: 580,
      height: 310
    },
    offset: {
      type: "center"
    },
    resizable: true
  });
  entity.events.create.push(function () {
    entity.$content.addClass("room-creation");
    const tabs = new DialogTabs("100%");
    tabs.$element.addClass("room-creation-tabs");
    tabs.add("information", "Information", async function ($element) {
      const $grid = $('<div class="room-creation-grid"></div>').appendTo($element);
      const $information = $('<div class="room-creation-information"></div>').appendTo($grid);
      $('<div class="room-creation-property">' + '<p>' + '<b>Room Name</b>' + '<span>Give your room a fun and interesting title, this is what interests others!</span>' + '</p>' + '<div class="input-pen">' + '<input type="text" class="room-creation-name" placeholder="Enter a room name..." value="' + RoomInterface.data.title + '">' + '</div>' + '</div>').appendTo($information).find(".room-creation-name").on("change", function () {
        SocketMessages.send({
          OnRoomSettingsUpdate: {
            title: $(this).val()
          }
        });
      });
      $('<div class="room-creation-property">' + '<p>' + '<b>Room Description</b>' + '<span>Describe what your room is, what can others do in your room, let them know what it is!</span>' + '</p>' + '<div class="textarea-pen">' + '<textarea type="text" class="room-creation-description" placeholder="Enter a room description...">' + RoomInterface.data.description + '</textarea>' + '</div>' + '</div>').appendTo($information).find(".room-creation-description").on("change", function () {
        SocketMessages.send({
          OnRoomSettingsUpdate: {
            description: $(this).val()
          }
        });
      });
    });
    tabs.add("map", "Map Editor", function ($element) {
      $element.parent().css("overflow", "visible");
      const $grid = $('<div class="room-creation-map"></div>').appendTo($element);
      const $settings = $('<div class="room-creation-properties"></div>').css({
        "display": "grid",
        "padding-bottom": "12px"
      }).appendTo($grid);
      $('<div class="room-creation-property">' + '<p>' + '<b>Map Editor</b>' + '<span>Use your mouse on the renderer to the left!</span><br><br>' + '<span>Hold shift and left click to use the current selected tool on the editor.</span><br><br>' + '<span>Press right click to copy the depth of an existing tile on the editor.</span>' + '</p>' + '</div>').appendTo($settings);
      const $toolsProperty = $('<div class="room-creation-property">' + '<p>' + '<b>Map Tools</b>' + '<span>Select what tool you want to use on the editor:</span>' + '</p>' + '<div class="room-creation-editor-tools"></div>' + '</div>').css("margin", "auto 0 0").appendTo($settings);
      const $tools = $toolsProperty.find(".room-creation-editor-tools");
      const data = {
        map: [],
        door: {
          row: RoomInterface.data.map.door.row,
          column: RoomInterface.data.map.door.column
        }
      };

      for (let row in RoomInterface.data.map.floor) data.map[row] = RoomInterface.data.map.floor[row];

      entity.editor = new Client.rooms.editor(data, async function (map, extra) {
        //entity.settings.map.map = map;
        //const $canvas = new RoomCreationMap(map.split('|'), entity.settings.map.door);
        //$settings.html($canvas);
        SocketMessages.send({
          OnRoomSettingsUpdate: {
            map: {
              floor: map,
              extra
            }
          }
        });
      });
      entity.editor.tiles.$element.css({
        "width": "auto",
        "height": "230px"
      });
      entity.editor.tiles.$element.prependTo($grid);
      entity.editor.depth.$element.css({
        "width": "280px",
        "height": "24px"
      });
      entity.editor.depth.$element.appendTo(entity.editor.tiles.$element);
      entity.editor.depth.render();
      const $add = $('<div class="dialog-item" value="0"></div>').appendTo($tools).append(entity.editor.tools.$add);
      const $remove = $('<div class="dialog-item" value="1"></div>').appendTo($tools).append(entity.editor.tools.$remove);
      const $up = $('<div class="dialog-item" value="2"></div>').appendTo($tools).append(entity.editor.tools.$up);
      const $down = $('<div class="dialog-item" value="3"></div>').appendTo($tools).append(entity.editor.tools.$down);
      const $door = $('<div class="dialog-item" value="4"></div>').appendTo($tools).append(entity.editor.tools.$door);
      $tools.on("click", ".dialog-item", function () {
        $tools.find(".dialog-item.active").removeClass("active");
        $(this).addClass("active");
        entity.editor.tools.setTool($(this).attr("value"));
      });
      $add.click();
    });
    tabs.add("walls", "Walls", function ($element) {
      const walls = Client.rooms.asset.room_visualization.visualizationData.wallData.walls.wall;
      const $container = $('<div class="room-creation-items"></div>').appendTo($element);
      const $content = $('<div class="room-creation-items-container"></div>').appendTo($container);
      const $items = $('<div class="room-creation-items-content"></div>').appendTo($content);
      const $preview = $('<div class="room-creation-items-preview"></div>').appendTo($container);
      const $canvas = $('<canvas width="200" height="200"></canvas>').appendTo($preview);
      const context = $canvas[0].getContext("2d");

      for (let index = 0; index < walls.length; index++) {
        const $item = $('<div class="dialog-item room-creation-item"></div>').appendTo($items);
        Assets.getSpritesheet("HabboRoomContentIcons/th_wall_" + walls[index].id, false).then(function (image) {
          $(image).appendTo($item);
        });
        $item.on("click", function () {
          $items.find(".room-creation-item.active").removeClass("active");
          $item.addClass("active");
          const map = new Client.rooms.map.entity(["XXXXXXX", "X000000", "X000000", "X000000", "X000000", "X000000", "X000000"], {}, {
            material: RoomInterface.data.floor_material
          }, {
            material: walls[index].id
          });
          map.render().then(function () {
            context.canvas.width = $preview.width();
            context.canvas.height = $preview.height();
            context.drawImage(map.$floor[0], -(8 * 16), 6 * 16 + -(map.depth * 16));
            context.drawImage(map.$wall[0], -(8 * 16), 6 * 16 + map.offset);
          });

          if (RoomInterface.data.wall_material != walls[index].id) {
            SocketMessages.send({
              OnRoomSettingsUpdate: {
                wall: {
                  material: walls[index].id
                }
              }
            });
          }
        });
        if (RoomInterface.data.wall_material == walls[index].id) $item.click();
      }
    });
    tabs.add("floors", "Floors", function ($element) {
      const floors = Client.rooms.asset.room_visualization.visualizationData.floorData.floors.floor;
      const $container = $('<div class="room-creation-items"></div>').appendTo($element);
      const $content = $('<div class="room-creation-items-container"></div>').appendTo($container);
      const $items = $('<div class="room-creation-items-content"></div>').appendTo($content);
      const $preview = $('<div class="room-creation-items-preview"></div>').appendTo($container);
      const $canvas = $('<canvas width="200" height="200"></canvas>').appendTo($preview);
      const context = $canvas[0].getContext("2d");

      for (let index = 0; index < floors.length; index++) {
        const $item = $('<div class="dialog-item room-creation-item"></div>').appendTo($items);
        Assets.getSpritesheet("HabboRoomContentIcons/th_floor_" + floors[index].id, false).then(function (image) {
          $(image).appendTo($item);
        });
        $item.on("click", function () {
          $items.find(".room-creation-item.active").removeClass("active");
          $item.addClass("active");
          const map = new Client.rooms.map.entity(["XXXXXXX", "X000000", "X000000", "X000000", "X000000", "X000000", "X000000"], {}, {
            material: floors[index].id
          }, {
            material: RoomInterface.data.wall_material
          });
          map.render().then(function () {
            context.canvas.width = $preview.width();
            context.canvas.height = $preview.height();
            context.drawImage(map.$floor[0], -(8 * 16), 6 * 16 + -(map.depth * 16));
            context.drawImage(map.$wall[0], -(8 * 16), 6 * 16 + map.offset);
          });

          if (RoomInterface.data.floor_material != floors[index].id) {
            SocketMessages.send({
              OnRoomSettingsUpdate: {
                floor: {
                  material: floors[index].id
                }
              }
            });
          }
        });
        if (RoomInterface.data.floor_material == floors[index].id) $item.click();
      }
    });
    tabs.click(function (identifier, $element) {
      if (entity.editor != undefined) entity.editor.destroy();
      $element.parent().css("overflow", "");
    });
    tabs.show("information");
    tabs.$element.appendTo(entity.$content);
  });
  entity.events.show.push(function () {});
  entity.events.destroy.push(function () {
    if (entity.editor != undefined) entity.editor.destroy();
  });
  return entity;
}();
RoomInterface.events.stop.push(function () {
  Client.rooms.settings.destroy();
});// @hash v3-9AB9A2FE5D8C41955B633B1A4C9C51B43412D674
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
const Hotel = new class {
  constructor() {
    this.element = document.createElement("div");
    this.element.id = "hotel";
    Client.element.prepend(this.element);
    RoomInterface.events.start.push(() => this.hide());
    RoomInterface.events.stop.push(() => this.show());
  }

  show() {
    this.element.classList.add("active");
  }

  hide() {
    this.element.classList.remove("active");
  }

}();// @hash v3-8A04DF081E28049AC58E1A323A94D236D0F2D796
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
const Menu = new class {
  constructor() {
    this.element = document.createElement("div");
    this.element.id = "menu";
    this.element.innerHTML = `
            <div class="menu-items"></div>

            <div class="menu-chat"></div>
        `;
    Client.element.append(this.element);
    this.icons = this.element.querySelector(".menu-items");
    this.chat = this.element.querySelector(".menu-chat");
    this.addItem("hotel", function () {});
    this.addItem("navigator", function () {
      Client.rooms.navigator.toggle();
    });
    this.addItem("shop", function () {
      Client.shop.toggle();
    });
    const inventory = this.addItem("inventory", function () {
      Inventory.toggle();
    });
    const camera = this.addItem("camera", function () {
      RoomInterface.camera.toggle();
    });
    RoomInterface.events.start.push(function () {
      inventory.style.display = "";
      camera.style.display = "";
    });
    RoomInterface.events.stop.push(function () {
      camera.style.display = "none";
      inventory.style.display = "none";
    });
  }

  addItem(identifier, callback) {
    const element = document.createElement("div");
    element.className = "menu-item";
    element.innerHTML = `<div class="menu-sprite menu-${identifier}"></div>`;
    element.addEventListener("click", () => callback());
    this.icons.append(element);
    return element;
  }

}();
Loader.ready(function () {
  const user = Menu.addItem("user", function () {
    WardrobeDialog.toggle(); //MenuSub.element.style.display = ((MenuSub.element.style.display == "none")?("block"):("none"));
  });
  user.innerHTML = "";
  const canvas = document.createElement("div");
  canvas.className = "menu-sprite menu-user";
  user.append(canvas);
  const entity = new FigureEntity(Client.user.figure);
  SocketMessages.register("OnUserUpdate", function (data) {
    if (data.figure == undefined) return;
    entity.setFigure(data.figure);
    entity.render();
  });
  entity.events.render.push(function () {
    canvas.append(entity.canvas);
  });
  entity.process().then(function () {
    entity.render();
  });
});// @hash v3-FE524DAC789CFB92B2BAF23F95FC84F5D147192E
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
var _temp;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const MenuSub = new (_temp = class {
  constructor() {
    _defineProperty(this, "addItem", function (sprite, click) {
      const element = document.createElement("div");
      element.className = "menu-sub-item";
      element.innerHTML = `<div class="menu-sub-sprite sprite-${sprite}"></div>`;
      this.element.append(element);
      element.addEventListener("click", click);
    });

    this.element = document.createElement("div");
    this.element.className = "menu-sub";
    Client.element.append(this.element);
    this.addItem("menu-sub-achievements", function () {});
  }

}, _temp)();// @hash v3-91676BCFB65E9C725D7AE982D29581F0D95FC5C0
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
var _temp;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const MenuFriends = new (_temp = class {
  constructor() {
    _defineProperty(this, "friends", {});

    this.element = document.createElement("div");
    this.element.className = "menu-friends";
    Menu.element.append(this.element);
    RoomInterface.events.stop.push(function () {
      for (let id in Client.user.friends) {
        if (Client.user.friends[id].request == undefined) continue;
        Client.user.friends[id].request.destroy();
        delete Client.user.friends[id].request;
      }
    });
  }

  add(id) {
    const element = document.createElement("div");
    element.className = "menu-friend";
    this.element.append(element);
    Game.getUser(id).then(async function (user) {
      const friend = Client.user.friends[id];
      const content = document.createElement("div");
      content.className = "menu-friend-content";
      content.innerHTML = `
                <p class="menu-friend-name">${user.name}</p>
                <div class="menu-friend-buttons"></div>
            `;
      element.append(content);
      const buttons = content.querySelector(".menu-friend-buttons");

      if (friend.status == 0) {
        element.classList.add("menu-friend-request");
      } else {
        element.addEventListener("click", function (e) {
          if (e.target.classList.contains("menu-friend-content")) element.classList.toggle("active");
        }); //$('<div class="menu-friend-follow sprite-user-follow"></div>').appendTo($buttons);
      }

      const figure = document.createElement("div");
      figure.className = "menu-friend-figure";
      figure.innerHTML = `
                <canvas class="menu-friend-figure-canvas" width="256" height="256"></canvas>
            `;
      content.append(figure);
      const canvas = figure.querySelector(".menu-friend-figure-canvas");
      const context = canvas.getContext("2d");
      const entity = new FigureEntity(user.figure);
      entity.events.render.push(function (sprites) {
        context.clearRect(0, 0, 256, 256);

        for (let index in sprites) context.drawImage(sprites[index].image, sprites[index].left, sprites[index].top);
      });
      await entity.process();
      await entity.render();
    });
    return element;
  }

}, _temp)();// @hash v3-BF707F5E634CC4FBDB82A0F22092FDC797D874A9
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
RoomInterface.chat.input = new function () {
  this.element = document.createElement("div");
  this.element.className = "room-interface-chat-input";
  this.element.innerHTML = `
        <input type="text" placeholder="Click here to chat...">
    `;
  Menu.chat.append(this.element);
  this.input = this.element.querySelector("input");
  this.input.addEventListener("keyup", event => {
    if (event.key != "Enter") return;
    if (this.input.value.length == 0) return;
    SocketMessages.send({
      OnRoomUserChat: this.input.value
    });
    this.input.value = "";
  });
}();// @hash v3-80B6C6BDA6A67D51DE63068543DB2FB27939DE2A
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
Client.shop = new function () {
  const entity = new Dialog({
    title: "Shop",
    size: {
      width: 580,
      height: 600
    },
    offset: {
      type: "center"
    }
  });
  entity.categories = {};
  entity.types = {};

  entity.setIcon = function (icon) {
    Assets.getSpritesheet("HabboShopIcons/icon_" + icon, false).then(function (spritesheet) {
      const context = entity.icon.getContext("2d");
      context.imageSmoothingEnabled = false;
      const width = spritesheet.width * 3,
            height = spritesheet.height * 3;
      context.clearRect(0, 0, context.canvas.width, context.canvas.height);
      context.drawImage(spritesheet, 0, 0, spritesheet.width, spritesheet.height, (context.canvas.width - width) / 2, (context.canvas.height - height) / 2, width, height);
    });
  };

  entity.setHeader = function (header) {
    const context = entity.header.getContext("2d");

    if (header.length == 0) {
      context.clearRect(0, 0, context.canvas.width, context.canvas.height);
      return;
    }

    Assets.getSpritesheet("HabboShopHeaders/" + header, false).then(function (spritesheet) {
      context.imageSmoothingEnabled = false;
      context.drawImage(spritesheet, 0, 0, spritesheet.width, spritesheet.height, -(spritesheet.width * 2 - 580) / 2, -(spritesheet.height * 2 - 95) / 2, spritesheet.width * 2, spritesheet.height * 2);
    });
  };

  entity.setPage = async function (id) {
    const page = entity.pages.find(x => x.id == id);
    if (!page.data) page.data = await SocketMessages.sendCall({
      OnShopPageUpdate: id
    }, "OnShopPageUpdate");
    entity.header.setTitle(page.title);
    entity.header.setDescription(page.data.description ? page.data.description : "");
    entity.setIcon(page.icon);
    entity.setHeader(page.data.header ? page.data.header : "");

    if (page.parent == 0) {
      try {
        Client.shop.tabs.content.innerHTML = "";
        entity.category = new Client.shop.categories[page.data.type](page);
      } catch (exception) {
        entity.tabs.content.innerHTML = exception;
      }
    } else {
      try {
        Client.shop.category.content.innerHTML = "";
        entity.page = await Client.shop.types[page.data.type](page);
      } catch (exception) {
        entity.category.content.innerHTML = exception;
      }
    }
  };

  entity.events.create.push(async function () {
    if (!entity.pages) entity.pages = await SocketMessages.sendCall({
      OnShopUpdate: null
    }, "OnShopUpdate");
    entity.header = new DialogHeader({
      height: 95
    });
    entity.content.append(entity.header.element);
    entity.tabs = new DialogTabs(500);
    entity.icon = document.createElement("canvas");
    entity.icon.width = 64;
    entity.icon.height = 64;
    entity.header.setIcon(entity.icon);
    const categories = entity.pages.filter(x => x.parent == 0);

    for (let index in categories) entity.tabs.add(categories[index].id, categories[index].title);

    entity.tabs.click(entity.setPage);
    entity.tabs.show(categories[0].id);
    entity.content.append(entity.tabs.element);
  });
  entity.events.show.push(function () {});
  return entity;
}();// @hash v3-7BE6B85592147F6811C29CB31075D62F3BE5E276
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
Client.shop.categories.default = function (page) {
  this.element = document.createElement("div");
  this.element.className = "shop-pages";
  this.element.innerHTML = `
        <div class="shop-pages-left">
            <div class="shop-pages-search input-pen">
                <input class="shop-pages-search-input" type="text" placeholder="Search...">
            </div>
            
            <div class="shop-pages-list dialog-container">
                <div class="shop-pages-list-container"></div>
            </div>
        </div>
        
        <div class="shop-pages-right"></div>
    `;
  this.search = this.element.querySelector(".shop-pages-search-input");
  this.search.addEventListener("change", () => {
    Client.shop.category = new Client.shop.categories.search(this.search.value);
  });
  this.list = this.element.querySelector(".shop-pages-list-container");
  this.content = this.element.querySelector(".shop-pages-right");

  this.addPage = function (page, parent) {
    const element = document.createElement("div");
    element.className = "shop-pages-item";
    element.innerHTML = `
            <div class="shop-pages-item-button">
                <canvas class="shop-pages-item-icon" width="20" height="20"></canvas>

                ${page.title}
            </div>
        `;
    parent.append(element);
    const button = element.querySelector(".shop-pages-item-button");
    button.addEventListener("click", () => {
      const active = parent.querySelector(".shop-pages-item.active");
      if (active != null) active.classList.remove("active");
      element.classList.add("active");
      Client.shop.setPage(page.id);
    });
    const icon = element.querySelector(".shop-pages-item-icon");
    const context = icon.getContext("2d");
    Assets.getSpritesheet("HabboShopIcons/icon_1", false).then(function (spritesheet) {
      context.drawImage(spritesheet, Math.floor((context.canvas.width - spritesheet.width) / 2), Math.floor((context.canvas.height - spritesheet.height) / 2));
      Assets.getSpritesheet("HabboShopIcons/icon_" + page.icon, false).then(function (spritesheet) {
        context.clearRect(0, 0, context.canvas.width, context.canvas.height);
        context.drawImage(spritesheet, Math.floor((context.canvas.width - spritesheet.width) / 2), Math.floor((context.canvas.height - spritesheet.height) / 2));
      });
    });
    const subPages = Client.shop.pages.filter(x => x.parent == page.id);
    if (subPages.length == 0) return;
    const list = document.createElement("div");
    list.className = "shop-pages-item-list";
    element.append(list);
    button.classList.add("shop-pages-item-drop");
    button.addEventListener("click", () => {
      element.classList.toggle("active");
    });

    for (let index in subPages) this.addPage(subPages[index], list);
  };

  const subPages = Client.shop.pages.filter(x => x.parent == page.id);

  for (let index in subPages) this.addPage(subPages[index], this.list);

  Client.shop.tabs.content.append(this.element);
};// @hash v3-B814C7207865CF8F7FD1A793905D7C7E9C4AA279
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
Client.shop.categories.search = function (input) {
  const $element = $('<div class="shop-pages">' + '<div class="shop-pages-left">' + '<div class="shop-pages-search input-pen">' + '<input class="shop-pages-search-input" type="text" placeholder="Search..." value="' + input + '">' + '</div>' + '<div class="shop-pages-list dialog-container">' + '<div class="shop-pages-list-container"></div>' + '</div>' + '</div>' + '<div class="shop-pages-right"></div>' + '</div>');
  const $search = $element.find(".shop-pages-search-input");
  $search.on("change", function () {
    Client.shop.category = new Client.shop.categories.search($(this).val());
  });
  const $list = $element.find(".shop-pages-list-container");
  this.$content = $element.find(".shop-pages-right");

  const addPage = function (page, $parent) {
    const $element = $('<div class="shop-pages-item">' + '<div class="shop-pages-item-button">' + '<canvas class="shop-pages-item-icon" width="20" height="20"></canvas>' + page.title + '</div>' + '</div>').appendTo($parent);
    const $button = $element.find(".shop-pages-item-button").on("click", function () {
      $parent.find(".shop-pages-item.active").removeClass("active");
      $element.addClass("active");
      Client.shop.setPage(page.id);
    });
    const $icon = $element.find(".shop-pages-item-icon");
    const context = $icon[0].getContext("2d");
    Assets.getSpritesheet("HabboShopIcons/icon_1", false).then(function (spritesheet) {
      context.drawImage(spritesheet, Math.floor((context.canvas.width - spritesheet.width) / 2), Math.floor((context.canvas.height - spritesheet.height) / 2));
      Assets.getSpritesheet("HabboShopIcons/icon_" + page.icon, false).then(function (spritesheet) {
        context.clearRect(0, 0, context.canvas.width, context.canvas.height);
        context.drawImage(spritesheet, Math.floor((context.canvas.width - spritesheet.width) / 2), Math.floor((context.canvas.height - spritesheet.height) / 2));
      });
    });
  };

  SocketMessages.sendCall({
    OnShopSearch: input
  }, "OnShopSearch").then(function (response) {
    for (let index in response.pages) addPage(response.pages[index], $list);

    Client.shop.page = Client.shop.types.default({
      id: null,
      furnitures: response.furnitures
    });
  });
  Client.shop.tabs.$content.html($element);
};// @hash v3-78D2B6991C26BFA4D23EF20ECA3C47D400A18B86
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
Client.shop.types.default = async function (page) {
  const element = document.createElement("div");
  element.className = "shop-furnitures";
  element.innerHTML = `
        <div class="shop-furnitures-display"></div>

        <div class="shop-furnitures-items dialog-container">
            <div class="shop-furnitures-items-container"></div>
        </div>
    `;
  const display = element.querySelector(".shop-furnitures-display");
  const items = element.querySelector(".shop-furnitures-items-container");
  if (!page.furnitures) page.furnitures = await SocketMessages.sendCall({
    OnShopFurnituresUpdate: page.id
  }, "OnShopFurnituresUpdate");

  for (let index in page.furnitures) {
    const furniture = page.furnitures[index].furniture;
    const item = document.createElement("div");
    item.className = "shop-furnitures-item";
    item.innerHTML = `
            <div class="shop-furnitures-item-icon"></div>
        `;
    items.append(item);
    const icon = item.querySelector(".shop-furnitures-item-icon");
    const canvas = document.createElement("canvas");
    icon.append(canvas);
    const renderer = new FurnitureRenderer({
      id: furniture.id,
      size: 1
    }, canvas);
    item.addEventListener("click", async () => {
      display.innerHTML = "";
      const canvas = document.createElement("canvas");
      canvas.className = "shop-furnitures-display-canvas";
      display.append(canvas);
      new FurnitureRenderer({
        id: furniture.id,
        direction: 4
      }, canvas, "#e9e9e1");
      const information = document.createElement("div");
      information.className = "shop-furnitures-display-info";
      information.innerHTML = ` 
                <b>${furniture.title}</b>
                <p>${furniture.description}</p>
            `;
      display.append(information);
      const button = document.createElement("div");
      button.className = "dialog-button shop-furnitures-display-button";
      button.innerHTML = `Add to inventory`;
      display.append(button);
      button.addEventListener("click", async () => {
        Client.shop.pause();
        await SocketMessages.sendCall({
          OnShopFurniturePurchase: page.furnitures[index].id
        }, "OnShopFurniturePurchase");
        Client.shop.unpause();
      });
    });
  }

  Client.shop.category.content.append(element);
};// @hash v3-66F531DAF0880FBD773F432C3AC60377392E85DB
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
const Inventory = new Dialog({
  title: "Inventory",
  size: {
    width: 480,
    height: 280
  },
  offset: {
    type: "center"
  },
  resizable: true
});
Inventory.pages = {};
Inventory.events.create.push(async function () {
  Inventory.tabs = new DialogTabs("280");
  Inventory.tabs.element.classList.add("inventory-tabs");
  Inventory.tabs.add("furnitures", "Furnitures");
  Inventory.tabs.add("badges", "Badges");
  Inventory.tabs.add("pets", "Pets", undefined, true);
  Inventory.tabs.add("bots", "Bots", undefined, true);
  Inventory.tabs.click(async function (identifier, $content) {
    try {
      Inventory.furnitures = {};
      Inventory.page = Inventory.pages[identifier]($content);
    } catch (exception) {
      content.innerHTML = exception;
    }
  });
  Inventory.tabs.show("furnitures");
  Inventory.content.append(Inventory.tabs.element);
});
Inventory.events.show.push(function () {
  if (RoomInterface.furniture.place.enabled == true) {
    RoomInterface.furniture.place.stop();
  }

  Inventory.tabs.show();
});// @hash v3-623518E0961102CDBE068358EA222590DD675E3D
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
Inventory.pages.furnitures = function (element) {
  element.innerHTML = `
        <div class="inventory-furnitures">
            <div class="inventory-furnitures-container">
                <div class="inventory-furnitures-content"></div>
            </div>

            <div class="inventory-furniture-display"></div>
        </div>
    `;
  const content = element.querySelector(".inventory-furnitures-content");
  const display = element.querySelector(".inventory-furniture-display");

  function setDisplay(furniture) {
    display.innerHTML = `
            <canvas class="inventory-furniture-display-canvas"></canvas>
            
            <div class="inventory-furniture-display-information">
                <b>${furniture.title}</b>
                <p>${furniture.description}</p>
            </div>
        `;

    if (RoomInterface.active == true) {
      const button = document.createElement("div");
      button.className = "dialog-button";
      button.innerText = "Place in room";
      display.querySelector(".inventory-furniture-display-information").append(button);
      button.addEventListener("click", () => {
        Inventory.hide();
        RoomInterface.furniture.place.start(furniture.id, result => {
          if (result.entity.enabled == false) {
            result.stop();
            Inventory.show();
            return;
          }

          result.unbind();
          SocketMessages.sendCall({
            OnRoomFurniturePlace: {
              id: result.furniture.id,
              position: {
                row: result.position.row,
                column: result.position.column,
                direction: result.entity.furniture.settings.direction
              }
            }
          }, "OnRoomFurniturePlace").then(response => {
            if (response == null) {
              result.stop();
              Inventory.show();
              return;
            }

            Client.user.furnitures[furniture.id].inventory--;
            if (Client.user.furnitures[furniture.id].rooms == undefined) Client.user.furnitures[furniture.id].rooms = 0;
            Client.user.furnitures[furniture.id].rooms++;
            setFurniture(furniture.id);

            if (Client.user.furnitures[furniture.id].inventory == 0) {
              result.stop();
              Inventory.show();
              return;
            }

            result.bind();
          });
        });
      });
    }

    const canvas = element.querySelector(".inventory-furniture-display-canvas");
    new FurnitureRenderer({
      id: furniture.id,
      direction: 4
    }, canvas);
  }

  ;

  function setFurniture(id) {
    if (!(Client.user.furnitures[id].inventory > 0)) {
      if (Inventory.furnitures[id] != undefined) {
        Inventory.furnitures[id].element.remove();
        Inventory.furnitures[id] = undefined;
      }

      return;
    }

    if (Inventory.furnitures[id] == undefined) {
      const element = document.createElement("div");
      element.className = "dialog-item inventory-furniture-icon";
      content.append(element);
      const canvas = document.createElement("canvas");
      canvas.className = "inventory-furniture-icon-image";
      element.append(canvas);
      const quantity = document.createElement("div");
      quantity.className = "inventory-furniture-icon-quantity";
      quantity.innerText = Client.user.furnitures[id].inventory;
      element.append(quantity);
      Inventory.furnitures[id] = {
        element,
        canvas,
        quantity
      };
    }

    Inventory.furnitures[id].quantity.innerHTML = Client.user.furnitures[id].inventory;
    if (Client.user.furnitures[id].inventory == 1) Inventory.furnitures[id].quantity.style.dispaly = "none";else Inventory.furnitures[id].quantity.style.dispaly = "block";
    Furnitures.get(id).then(function (furniture) {
      const renderer = new FurnitureRenderer({
        id: furniture.id,
        size: 1
      }, Inventory.furnitures[id].canvas);
      Inventory.furnitures[id].element.addEventListener("click", () => {
        const active = Inventory.furnitures[id].element.parentElement.querySelector(".active");
        if (active != null) active.classList.remove("active");
        Inventory.furnitures[id].element.classList.add("active");
        setDisplay(furniture);
      });
    });
  }

  ;

  for (let id in Client.user.furnitures) setFurniture(id);
};// @hash v3-DA62DA857B3E2B493CD0025AD82F8038E2D100FB
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
Inventory.pages.badges = async function (element) {
  element.innerHTML = `
        <div class="inventory-badges">
            <div class="inventory-badges-grid">
                <div class="inventory-badges-container">
                    <div class="inventory-badges-unequipped"></div>
                </div>

                <div class="inventory-badges-equipped"></div>
            </div>

            <div class="inventory-badges-info">
                <div class="inventory-badges-info-badge"></div>
                <div class="inventory-badges-info-content"></div>
                <div class="inventory-badges-info-button"></div>
            </div>
        </div>
    `;
  const infoBadge = element.querySelector(".inventory-badges-info-badge");
  const infoContent = element.querySelector(".inventory-badges-info-content");
  const infoButton = element.querySelector(".inventory-badges-info-button");
  const uneqipped = element.querySelector(".inventory-badges-unequipped");
  const equipped = element.querySelector(".inventory-badges-equipped");
  const badges = await SocketMessages.sendCall({
    OnUserInventoryBadges: null
  }, "OnUserInventoryBadges");

  for (let index in badges) {
    const badge = document.createElement("div");
    badge.className = "dialog-item inventory-badges-icon";
    (badges[index].equipped ? equipped : uneqipped).prepend(badge);
    const badgeRenderer = new BadgeRenderer(badges[index].badge);
    badgeRenderer.classList.add("inventory-badges-icon-image");
    badge.append(badgeRenderer);

    async function click() {
      element.querySelector(".inventory-badges-icon.active").classList.remove("active");
      badge.classList.add("active");
      infoBadge.innerHTML = new BadgeRenderer(badges[index].badge);
      const badge = await Badges.get(badges[index].badge);
      infoContent.innerHTML = `
                <b>${badge.title}</b>
                <p>${badge.description}</p>
            `;
      infoButton.innerHTML = "";
      const button = document.createElement("div");
      button.className = "dialog-button";
      button.innerText = badges[index].equipped ? "Unequip" : "Equip";
      button.addEventListener("click", async () => {
        Inventory.pause();
        const result = await SocketMessages.sendCall({
          OnUserInventoryBadges: {
            id: badges[index].badge
          }
        }, "OnUserInventoryBadges");
        Inventory.unpause();

        if (result == true) {
          badges[index].equipped = !badges[index].equipped;
          badge.remove();
          (badges[index].equipped ? equipped : uneqipped).append(badge);
          badge.addEventListener("click", click);
          click();
        }
      });
      infoButton.append(button);
    }

    ;
    badge.on("click", click);
  }

  let first = equipped.querySelector(".inventory-badges-icon");
  if (first == null) first = uneqipped.querySelector(".inventory-badges-icon");
  first.click();
};// @hash v3-F5436C1CE4764F854F8DD209ABCBE71EEAE5C266
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
Client.user = new function () {
  this.home = null;
  this.furnitures = {};
  this.figure = "hr-100.hd-180-1.ch-210-66.lg-270-82.sh-290-91";
  this.friends = {};
  SocketMessages.register("OnUserUpdate", function (data) {
    for (let key in data) Client.user[key] = data[key];
  });
  SocketMessages.register("OnUserFurnitureUpdate", function (data) {
    for (let key in data) Client.user.furnitures[key] = data[key];

    if (Inventory.active && Inventory.tabs.selected == "furnitures") for (let key in data) Inventory.page.setFurniture(key);
  });
}();// @hash v3-49E31BDECF391351FF2846D6CDCA7F60A1D6B1F2
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
const WardrobeDialog = new class extends Dialog {
  constructor(settings = {}) {
    settings = {
      title: "User Wardrobe",
      size: {
        width: 580,
        height: 310
      }
    };
    super(settings);
    this.events.create.push(async () => {
      this.tabs = new DialogTabs("100%");
      this.tabs.element.classList.add("inventory-tabs");
      this.tabs.add("body", "Body");
      this.tabs.add("head", "Head");
      this.tabs.add("top", "Top");
      this.tabs.add("bottom", "Bottom");
      this.tabs.add("shoes", "Shoes");
      this.tabs.click(async function (identifier, content) {});
      this.tabs.show("body");
      this.content.append(this.tabs.element);
    });
  }

}();// @hash v3-2542C53CC92B1EC35DA490D93E95BF80FF5E8652
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
SocketMessages.register("OnUserFriendUpdate", function (data) {
  if (data.length == undefined) data = [data];

  for (let index in data) {
    const id = data[index].id;
    if (Client.user.friends[id] == undefined) Client.user.friends[id] = {};
    if (data[index].status == 0 && Client.user.friends[id].status != data[index].status && Client.user.friends[id].request == undefined && RoomInterface.users[id] != undefined) data[index].request = new RoomInterface.display.users.request(RoomInterface.users[id]);
    if (Client.user.friends[id].menu != undefined) Client.user.friends[id].menu.remove();
    if (data[index].status != -1) data[index].menu = MenuFriends.add(id);

    for (let key in data[index]) Client.user.friends[id][key] = data[index][key];
  }
});// @hash v3-747055C2EC131501CF5663536ACB76DC298F0BE3
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
SocketMessages.register("OnUserFriendRemove", function (data) {
  if (Client.user.friends[data] == undefined) return;
  if (Client.user.friends[data].request != undefined) Client.user.friends[data].request.destroy();
  if (Client.user.friends[data].menu != undefined) Client.user.friends[data].menu.remove();
  delete Client.user.friends[data];
});// @hash v3-96A55E50BD617E51EF5F20240AF53704EB64CDC8
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
SocketMessages.register("OnUserBadgeAdd", function (data) {
  const entity = new DisplayDialog({
    title: "Badge Unlocked"
  });
  entity.show();
  const renderer = BadgeRenderer(data.badge);
  renderer.style.margin = "auto";
  entity.display.append(renderer);
  Badges.get(data.badge).then(function (data) {
    entity.info.innerHTML = `
            <h1>Congratulations!</h1>
            <p>You have received the badge <b>${data.title}</b></p>
            <p>${data.description}</p>'
        `;
  });
});// @hash v3-5D2D07346EA97CC35DC1D774670ECFB95E10F045
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
Client.theme = new function () {
  this.data = {};

  this.get = function (path, value) {
    const keys = path.split('/');
    let data = this.data;

    for (let index in keys) {
      if (data[keys[index]] == undefined) return value;
      data = data[keys[index]];
    }

    return data;
  };
}();// @hash v3-711E9D82F93FBA8123F80C76806EFC4B2B9DE69E
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2022-04-07 23:14:23
///////////////////////////////////////////////////////////////////////////////
Client.utils = new function () {
  this.colors = {
    "Loader": "orange",
    "Assets": "skyblue",
    "Socket": "pink",
    "SocketMessages": "pink"
  };

  this.log = function (header, message, indent = 0, tab = false) {
    const name = header.split(':')[0];

    if (this.colors[name] != undefined) {
      indent = 64 + indent * 32;
      return console.log((tab ? "\t" : "") + "[%c" + header + "%c] %c" + message, "color: " + this.colors[name] + "", "color: inherit", "color: " + (indent != 0 ? "rgba(" + (255 - indent) + ", " + (255 - indent) + ", " + (255 - indent) + ", 1)" : "inherit"));
    }

    return console.log((tab ? "\t" : "") + "[" + header + "] " + message);
  };

  this.warn = function (header, message, tab = false) {
    return console.warn((tab ? "\t" : "") + "[" + header + "] " + message);
  };

  this.error = function (header, message, tab = false) {
    return console.error((tab ? "\t" : "") + "[" + header + "] " + message);
  };

  this.info = function (header, message, tab = false) {
    return console.info((tab ? "\t" : "") + "[" + header + "] " + message);
  };

  this.object = function (header, message, object, tab = false) {
    const name = header.split(':')[0];
    if (this.colors[name] != undefined) return console.log((tab ? "\t" : "") + "[%c" + header + "%c] %c" + message + " %o", "color: " + this.colors[name] + "", "color: inherit", "color: inherit", object);
    return console.log((tab ? "\t" : "") + "[" + header + "] %o", object);
  };

  this.isLetter = function (character) {
    return character.toLowerCase() != character.toUpperCase();
  };

  this.charCode = function (number) {
    return String.fromCharCode(97 + number);
  };

  this.fromCharCode = function (number) {
    return number.charCodeAt(0) - 97;
  };

  this.getArrayMedian = function (array) {
    const newArray = JSON.parse(JSON.stringify(array));
    newArray.sort(function (a, b) {
      return a - b;
    });
    var i = newArray.length / 2;
    return i % 1 == 0 ? (newArray[i - 1] + newArray[i]) / 2 : newArray[Math.floor(i)];
  };

  this.getStringMarkup = function (string) {
    const parts = [{
      type: "Regular",
      message: ""
    }];
    let currentPart = 0;

    for (let character = 0, length = string.length; character < length; character++) {
      let occurances = 0;

      for (let index in string) {
        if (string[index] == '*') occurances++;
      }

      if (string[character] != '*' || occurances == 1) {
        parts[currentPart].message += string[character];
        string = string.substring(character, length);
        character = 0;
        length = string.length;
        continue;
      }

      if (string[character] == '*') {
        if (string[character + 1] == '*') {
          if (character + 2 == length) break;

          if (parts[currentPart].type == "Bold") {
            parts.push({
              type: "Regular",
              message: ""
            });
            currentPart++;
          } else if (parts[currentPart].type != "Bold") {
            parts.push({
              type: "Bold",
              message: ""
            });
            currentPart++;
          }

          character++;
        } else {
          if (character + 1 == length) break;

          if (parts[currentPart].type == "Italic") {
            parts.push({
              type: "Regular",
              message: ""
            });
            currentPart++;
          } else if (parts[currentPart].type != "Italic") {
            parts.push({
              type: "Italic",
              message: ""
            });
            currentPart++;
          }
        }

        string = string.substring(character, length);
        character = 0;
        length = string.length;
      }
    }

    return parts;
  };
}();